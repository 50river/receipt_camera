<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>領収書OCRアプリ</title>
  <style>
    /* ページ全体の基本レイアウト */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #f0f0f0;
    }
    #app {
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      background: #fff;
      min-height: 100vh;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    /* ヘッダー */
    #header {
      background: #007aff;
      color: #fff;
      padding: 10px;
      text-align: center;
    }
    /* スクリーンの基本スタイル */
    .screen {
      display: none;
      padding: 10px;
    }
    .screen.active {
      display: block;
    }
    h1, h2, h3, p {
      margin: 10px 0;
    }
    hr {
      margin: 20px 0;
    }
    /* キャンバスコンテナ */
    #pcCanvasContainer, #fsCanvasContainer {
      position: relative;
      margin: 0 auto;
    }
    /* キャンバスのスタイル */
    #pcCanvas, #fsCanvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      display: block;
      width: 100%;
      height: auto;
      touch-action: none;
    }
    /* ボタン・ドロップダウン */
    button, select {
      margin: 10px 5px;
      font-size: 1.5em;
      padding: 0.15em 0.25em;
    }
    /* 補正済み画像 */
    #correctedImage {
      border: 1px solid #ccc;
      max-width: 50%;
      display: block;
      margin: 10px auto;
    }
    /* 入力フィールド */
    .field-group {
      margin-top: 10px;
    }
    label {
      display: inline-block;
      width: 80px;
    }
    input[type="text"] {
      width: calc(100% - 90px);
      padding: 3px;
    }
    /* OCR進捗表示（画面上部） */
    #ocrOutput {
      white-space: pre-wrap;
      font-family: sans-serif;
      border: 1px solid #ccc;
      padding: 10px;
      background: #f9f9f9;
      margin-bottom: 10px;
    }
    /* OCRグループ化パラメータ設定 */
    #ocrThresholdControls {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #ccc;
    }
    @media (max-width: 600px) {
      #header { padding: 8px; font-size: 1.2em; }
      button, select { font-size: 1.2em; padding: 0.1em 0.2em; }
      input[type="text"] { font-size: 1em; }
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- ヘッダー -->
    <div id="header">
      <h1>領収書OCRアプリ</h1>
    </div>
    
    <!-- スクリーン１：画像切り出し＆補正 -->
    <div id="screen1" class="screen active">
      <h2>画像切り出し＆補正</h2>
      <p>画像ファイルを選択し、クロッピング用の編集枠を調整してください。</p>
      <input type="file" id="imageInput" accept="image/*">
      <div id="pcCanvasContainer">
        <canvas id="pcCanvas"></canvas>
      </div>
      <button id="autoCropButton">自動切り出し＆補正を実行</button>
      <button id="confirmPointsButton" style="display:none;">ポイント確定</button>
      <h3>補正結果</h3>
      <img id="correctedImage" alt="Corrected Image">
      <div id="transformControls" style="display:none; margin-top:10px;">
        <button id="rotate90Button">Rotate 90°</button>
        <button id="rotateNeg90Button">Rotate -90°</button>
        <button id="flipButton">Flip Horizontally</button>
      </div>
      <br>
      <button id="nextToScreen2">次へ</button>
    </div>
    
    <!-- スクリーン２：フィールド選択＆OCR -->
    <div id="screen2" class="screen">
      <h2>フィールド選択＆OCR</h2>
      
      <!-- OCR進捗表示（画面上部固定） -->
      <div id="ocrOutput"></div>
      
      <!-- OCR済み画像キャンバス -->
      <div id="fsCanvasContainer">
        <canvas id="fsCanvas"></canvas>
      </div>
      
      <!-- 入力フォーム（キャンバス直下に配置） -->
      <div class="field-group">
        <label for="dateField">日付:</label>
        <input type="text" id="dateField" placeholder="OCR結果">
      </div>
      <div class="field-group">
        <label for="amountField">金額:</label>
        <input type="text" id="amountField" placeholder="OCR結果">
      </div>
      <div class="field-group">
        <label for="payeeField">支払先:</label>
        <input type="text" id="payeeField" placeholder="OCR結果">
      </div>
      <div class="field-group">
        <label for="descriptionField">摘要:</label>
        <input type="text" id="descriptionField" placeholder="OCR結果">
      </div>
      
      <!-- その他のコントロール -->
      <label for="fieldSelector">対象項目:</label>
      <select id="fieldSelector">
        <option value="">--フィールドを選択--</option>
        <option value="date">日付</option>
        <option value="amount">金額</option>
        <option value="payee">支払先</option>
        <option value="description">摘要</option>
      </select>
      <button id="fsResetButton">フィールドリセット</button>
      <button id="fsOcrButton">選択領域でOCR実行</button>
      <button id="ocrWholeButton">全体OCR実行</button>
      <div id="ocrThresholdControls">
        <h3>OCRグループ化パラメータ設定</h3>
        <div style="margin-bottom: 10px;">
          <label for="groupThresholdSlider">
            行グループ化閾値: <span id="groupThresholdValue">10</span>px
          </label>
          <input type="range" id="groupThresholdSlider" min="5" max="50" value="10">
        </div>
        <div>
          <label for="overlapThresholdSlider">
            横方向重なり閾値: <span id="overlapThresholdValue">0.5</span>
          </label>
          <input type="range" id="overlapThresholdSlider" min="0.1" max="1.0" step="0.1" value="0.5">
        </div>
      </div>
      <button id="backToScreen1">戻る</button>
    </div>
  </div>
  
  <!-- ライブラリ読み込み -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <script async src="https://docs.opencv.org/3.4.0/opencv.js"></script>
  
  <script>
    /*************************************
     * グローバル変数
     *************************************/
    let lastGroupBoxes = [];  // 全体OCR結果から算出されたグループの赤枠情報（フィールドリセットまで保持）
    let lastOcrData = null;   // 全体OCRの結果データ
    let groupOcrResults = {}; // 各グループのOCR結果（キー：グループ番号）
    let selectedGroupIndex = null; // キャンバス上で選択されたグループのインデックス
    let currentInput = null;  // 現在フォーカスされている入力フォーム
    
    /*************************************
     * 入力フォームのフォーカス処理
     * 新しい入力フォームにフォーカスすると前回のグループ選択はクリアする
     *************************************/
    ["dateField", "amountField", "payeeField", "descriptionField"].forEach(id => {
      const input = document.getElementById(id);
      input.addEventListener("focus", function() {
        currentInput = this;
        selectedGroupIndex = null;
      });
    });
    
    /*************************************
     * OCR結果を入力フォームに貼り付ける関数
     * 貼り付け後、次回の貼り付け対象をクリアするため currentInput をリセット
     *************************************/
    function pasteOcrResultIntoInput() {
      if (currentInput && selectedGroupIndex !== null) {
        if (groupOcrResults.hasOwnProperty(selectedGroupIndex)) {
          currentInput.value = groupOcrResults[selectedGroupIndex];
          currentInput.focus();
          currentInput = null;
        } else {
          performOCROnField("selected", lastGroupBoxes[selectedGroupIndex]).then(resultText => {
            if (currentInput.id === "dateField") {
              resultText = processDateField(resultText);
            }
            groupOcrResults[selectedGroupIndex] = resultText;
            currentInput.value = resultText;
            currentInput.focus();
            currentInput = null;
          }).catch(err => console.error("OCR error:", err));
        }
      }
    }
    
    /*************************************
     * 画面遷移処理
     * 画面遷移時に常にページ先頭にスクロールし、スクリーン２では全体OCRを自動開始
     *************************************/
    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.toggle('active', screen.id === screenId);
      });
      window.scrollTo(0, 0);
      if (screenId === 'screen1') {
        drawPcCanvasWithPoints();
      }
      if (screenId === 'screen2') {
        drawFsCanvas();
        ocrWholeButton.click(); // スクリーン２遷移時に自動で全体OCRを開始
      }
    }
    
    document.getElementById('nextToScreen2').addEventListener('click', function() {
      if (!correctedImage.src) {
        alert("補正結果画像がありません。");
        return;
      }
      showScreen('screen2');
    });
    
    document.getElementById('backToScreen1').addEventListener('click', function() {
      showScreen('screen1');
    });
    
    /*************************************
     * PCモード：画像切り出し＆補正処理
     *************************************/
    let pcScale = 1;
    let detectedPoints = [];
    let draggingPointIndex = -1;
    const AREA_THRESHOLD = 10000;
    const pcCanvas = document.getElementById('pcCanvas');
    const pcCtx = pcCanvas.getContext('2d');
    let pcImage = new Image();
    
    // 画像ファイル選択後、画像を読み込みpcCanvasに描画する
    const imageInput = document.getElementById('imageInput');
    const autoCropButton = document.getElementById('autoCropButton');
    const confirmPointsButton = document.getElementById('confirmPointsButton');
    const correctedImage = document.getElementById('correctedImage');
    const transformControls = document.getElementById('transformControls');
    
    imageInput.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const reader = new FileReader();
        reader.onload = event => { pcImage.src = event.target.result; };
        reader.readAsDataURL(e.target.files[0]);
      }
    });
    
    pcImage.onload = function() {
      const maxDisplayWidth = window.innerWidth - 40;
      pcScale = (pcImage.width > maxDisplayWidth) ? (maxDisplayWidth / pcImage.width) : 1;
      pcCanvas.width = pcImage.width * pcScale;
      pcCanvas.height = pcImage.height * pcScale;
      pcCtx.clearRect(0, 0, pcCanvas.width, pcCanvas.height);
      pcCtx.drawImage(pcImage, 0, 0, pcCanvas.width, pcCanvas.height);
      detectedPoints = [];
      confirmPointsButton.style.display = "none";
      transformControls.style.display = "none";
    };
    
    // 自動切り出し処理（画像から4点を検出してpcCanvasに描画）
    function autoCrop() {
      if (!pcImage.src) {
        alert("画像が読み込まれていません。");
        return;
      }
      const srcMat = cv.imread(pcCanvas);
      const gray = new cv.Mat();
      cv.cvtColor(srcMat, gray, cv.COLOR_RGBA2GRAY, 0);
      const blurred = new cv.Mat();
      cv.GaussianBlur(gray, blurred, new cv.Size(7, 7), 0);
      const edges = new cv.Mat();
      cv.Canny(blurred, edges, 50, 150);
      const kernel = cv.Mat.ones(3, 3, cv.CV_8U);
      const dilated = new cv.Mat();
      cv.dilate(edges, dilated, kernel);
      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(dilated, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      
      let maxArea = 0, bestContour = null;
      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        const peri = cv.arcLength(cnt, true);
        const approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
        if (approx.rows === 4) {
          const area = cv.contourArea(approx);
          if (area > AREA_THRESHOLD && area > maxArea) {
            maxArea = area;
            if (bestContour !== null) bestContour.delete();
            bestContour = approx;
          } else {
            approx.delete();
          }
        } else {
          approx.delete();
        }
        cnt.delete();
      }
      hierarchy.delete(); edges.delete(); dilated.delete(); kernel.delete();
      blurred.delete(); gray.delete();
      
      if (bestContour === null) {
        // 輪郭が見つからない場合はデフォルトの枠を設定
        const marginX = pcCanvas.width * 0.1;
        const marginY = pcCanvas.height * 0.1;
        detectedPoints = [
          { x: marginX, y: marginY },
          { x: pcCanvas.width - marginX, y: marginY },
          { x: pcCanvas.width - marginX, y: pcCanvas.height - marginY },
          { x: marginX, y: pcCanvas.height - marginY }
        ];
        drawPcCanvasWithPoints();
        confirmPointsButton.style.display = "inline-block";
        srcMat.delete();
        return;
      }
      
      detectedPoints = [];
      for (let i = 0; i < 4; i++) {
        detectedPoints.push({ x: bestContour.intAt(i, 0), y: bestContour.intAt(i, 1) });
      }
      bestContour.delete();
      detectedPoints = orderPoints(detectedPoints);
      drawPcCanvasWithPoints();
      confirmPointsButton.style.display = "inline-block";
      srcMat.delete();
    }
    
    // 4点の順番を整列（左上、右上、右下、左下）
    function orderPoints(pts) {
      const sumArr = pts.map(p => p.x + p.y);
      const diffArr = pts.map(p => p.x - p.y);
      const tl = pts[sumArr.indexOf(Math.min(...sumArr))];
      const br = pts[sumArr.indexOf(Math.max(...sumArr))];
      const tr = pts[diffArr.indexOf(Math.min(...diffArr))];
      const bl = pts[diffArr.indexOf(Math.max(...diffArr))];
      return [tl, tr, br, bl];
    }
    
    // PCキャンバスに画像と検出された4点、及びそれらを結ぶ線を描画
    function drawPcCanvasWithPoints() {
      pcCtx.clearRect(0, 0, pcCanvas.width, pcCanvas.height);
      pcCtx.drawImage(pcImage, 0, 0, pcCanvas.width, pcCanvas.height);
      detectedPoints.forEach(pt => {
        pcCtx.beginPath();
        pcCtx.arc(pt.x, pt.y, 15, 0, 2 * Math.PI);
        pcCtx.fillStyle = "blue";
        pcCtx.fill();
      });
      if (detectedPoints.length === 4) {
        pcCtx.beginPath();
        pcCtx.moveTo(detectedPoints[0].x, detectedPoints[0].y);
        for (let i = 1; i < 4; i++) {
          pcCtx.lineTo(detectedPoints[i].x, detectedPoints[i].y);
        }
        pcCtx.closePath();
        pcCtx.strokeStyle = "blue";
        pcCtx.lineWidth = 4;
        pcCtx.stroke();
      }
    }
    
    autoCropButton.addEventListener('click', autoCrop);
    
    // PCキャンバス上の4点をドラッグ操作で移動できるようにする
    pcCanvas.addEventListener('pointerdown', function(e) {
      if (detectedPoints.length !== 4) return;
      e.preventDefault();
      const rect = pcCanvas.getBoundingClientRect();
      const scaleX = pcCanvas.width / rect.width;
      const scaleY = pcCanvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      draggingPointIndex = -1;
      for (let i = 0; i < 4; i++) {
        if (Math.hypot(detectedPoints[i].x - x, detectedPoints[i].y - y) < 15) {
          draggingPointIndex = i;
          break;
        }
      }
    });
    
    pcCanvas.addEventListener('pointermove', function(e) {
      if (draggingPointIndex === -1) return;
      e.preventDefault();
      const rect = pcCanvas.getBoundingClientRect();
      const scaleX = pcCanvas.width / rect.width;
      const scaleY = pcCanvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      detectedPoints[draggingPointIndex] = { x, y };
      drawPcCanvasWithPoints();
    });
    
    pcCanvas.addEventListener('pointerup', e => { e.preventDefault(); draggingPointIndex = -1; });
    
    // confirmPointsButton: 調整後の4点を元に透視変換し、補正画像を生成する
    confirmPointsButton.addEventListener('click', function() {
      if (detectedPoints.length !== 4) {
        alert("4点が設定されていません。");
        return;
      }
      const ptsOriginal = detectedPoints.map(pt => ({ x: pt.x / pcScale, y: pt.y / pcScale }));
      const [tl, tr, br, bl] = orderPoints(ptsOriginal);
      
      const widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
      const widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
      const maxWidth = Math.max(widthA, widthB);
      
      const heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
      const heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
      const maxHeight = Math.max(heightA, heightB);
      
      const offCanvas = document.createElement('canvas');
      offCanvas.width = pcImage.width;
      offCanvas.height = pcImage.height;
      const offCtx = offCanvas.getContext('2d');
      offCtx.drawImage(pcImage, 0, 0);
      const srcMat = cv.imread(offCanvas);
      
      const srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        tl.x, tl.y,
        tr.x, tr.y,
        br.x, br.y,
        bl.x, bl.y
      ]);
      const dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        0, 0,
        maxWidth - 1, 0,
        maxWidth - 1, maxHeight - 1,
        0, maxHeight - 1
      ]);
      
      const M = cv.getPerspectiveTransform(srcPts, dstPts);
      const dsize = new cv.Size(maxWidth, maxHeight);
      const dstMat = new cv.Mat();
      cv.warpPerspective(srcMat, dstMat, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = maxWidth;
      tempCanvas.height = maxHeight;
      cv.imshow(tempCanvas, dstMat);
      const croppedDataURL = tempCanvas.toDataURL();
      
      // 回転・反転処理を実行
      rotateImage(croppedDataURL, 90)
        .then(rotatedDataURL => flipImage(rotatedDataURL))
        .then(finalDataURL => {
          correctedImage.src = finalDataURL;
          fsImage.src = finalDataURL;
          transformControls.style.display = "block";
        });
      
      srcMat.delete(); dstMat.delete(); srcPts.delete(); dstPts.delete(); M.delete();
      detectedPoints = [];
      confirmPointsButton.style.display = "none";
    });
    
    /*************************************
     * FSモード：フィールド選択＆OCR処理
     *************************************/
    let fsImage = new Image();
    const fsCanvas = document.getElementById('fsCanvas');
    const fsCtx = fsCanvas.getContext('2d');
    let fsScale = 1;
    let fsFieldRegions = {};
    
    // 入力フォーム・各種コントロールの取得
    const fieldSelector = document.getElementById('fieldSelector');
    const fsResetButton = document.getElementById('fsResetButton');
    const fsOcrButton = document.getElementById('fsOcrButton');
    const ocrWholeButton = document.getElementById('ocrWholeButton');
    const ocrOutput = document.getElementById('ocrOutput');
    const dateField = document.getElementById('dateField');
    const amountField = document.getElementById('amountField');
    const payeeField = document.getElementById('payeeField');
    const descriptionField = document.getElementById('descriptionField');
    
    fsImage.onload = function() {
      const maxDisplayWidth = window.innerWidth - 40;
      fsScale = (fsImage.width > maxDisplayWidth) ? (maxDisplayWidth / fsImage.width) : 1;
      fsCanvas.width = fsImage.width * fsScale;
      fsCanvas.height = fsImage.height * fsScale;
      fsFieldRegions = {};
      drawFsCanvas();
    };
    
    // drawFsCanvas: FS用キャンバスに画像、ユーザー指定フィールド枠、赤枠グループ、選択グループ（オレンジ）を描画
    function drawFsCanvas() {
      fsCtx.clearRect(0, 0, fsCanvas.width, fsCanvas.height);
      fsCtx.drawImage(fsImage, 0, 0, fsCanvas.width, fsCanvas.height);
      // ユーザー指定フィールド枠（赤）を描画
      for (const field in fsFieldRegions) {
        if (field === "amount" && Array.isArray(fsFieldRegions[field])) {
          fsFieldRegions[field].forEach(region => {
            fsCtx.strokeStyle = "red";
            fsCtx.lineWidth = 4;
            fsCtx.strokeRect(region.x, region.y, region.width, region.height);
            fsCtx.fillStyle = "rgba(255,255,255,0.7)";
            fsCtx.fillRect(region.x, region.y - 20, 60, 20);
            fsCtx.fillStyle = "red";
            fsCtx.font = "14px Arial";
            fsCtx.fillText(field, region.x + 2, region.y - 5);
          });
        } else {
          const r = fsFieldRegions[field];
          fsCtx.strokeStyle = "red";
          fsCtx.lineWidth = 4;
          fsCtx.strokeRect(r.x, r.y, r.width, r.height);
          fsCtx.fillStyle = "rgba(255,255,255,0.7)";
          fsCtx.fillRect(r.x, r.y - 20, 50, 20);
          fsCtx.fillStyle = "red";
          fsCtx.font = "14px Arial";
          fsCtx.fillText(field, r.x + 2, r.y - 5);
        }
      }
      // 赤枠グループ情報（lastGroupBoxes）は常に保持して描画
      if (lastGroupBoxes.length > 0) {
        drawGroupedBoxes(lastGroupBoxes);
      }
      // 選択グループがあればオレンジでハイライト
      if (selectedGroupIndex !== null && lastGroupBoxes[selectedGroupIndex]) {
        let box = lastGroupBoxes[selectedGroupIndex];
        fsCtx.strokeStyle = "orange";
        fsCtx.lineWidth = 4;
        fsCtx.strokeRect(box.x, box.y, box.width, box.height);
      }
    }
    
    // フィールド枠（ユーザー指定領域）のドラッグ描画処理
    let fsIsDrawing = false, fsStartX, fsStartY, fsCurrentX, fsCurrentY;
    
    fsCanvas.addEventListener('pointerdown', function(e) {
      // 入力フォームがフォーカス中ならグループ選択処理を行う
      if (currentInput) return;
      if (!fieldSelector.value) {
        alert("まずは対象項目を選択してください。");
        return;
      }
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      fsStartX = (e.clientX - rect.left) * scaleX;
      fsStartY = (e.clientY - rect.top) * scaleY;
      fsIsDrawing = true;
    });
    
    fsCanvas.addEventListener('pointermove', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      fsCurrentX = (e.clientX - rect.left) * scaleX;
      fsCurrentY = (e.clientY - rect.top) * scaleY;
      drawFsCanvas();
      fsCtx.strokeStyle = "blue";
      fsCtx.lineWidth = 4;
      fsCtx.strokeRect(fsStartX, fsStartY, fsCurrentX - fsStartX, fsCurrentY - fsStartY);
    });
    
    fsCanvas.addEventListener('pointerup', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      fsIsDrawing = false;
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      fsCurrentX = (e.clientX - rect.left) * scaleX;
      fsCurrentY = (e.clientY - rect.top) * scaleY;
      const x = Math.min(fsStartX, fsCurrentX);
      const y = Math.min(fsStartY, fsCurrentY);
      const width = Math.abs(fsCurrentX - fsStartX);
      const height = Math.abs(fsCurrentY - fsStartY);
      if (width === 0 || height === 0) return;
      const field = fieldSelector.value;
      if (field === "amount") {
        if (!fsFieldRegions[field]) fsFieldRegions[field] = [];
        fsFieldRegions[field].push({ x, y, width, height });
      } else {
        fsFieldRegions[field] = { x, y, width, height };
      }
      drawFsCanvas();
    });
    
    /*************************************
     * fsResetButton: リセット処理
     * ユーザー指定フィールド、グループ選択、OCR結果、赤枠情報を全てクリア
     *************************************/
    fsResetButton.addEventListener('click', function() {
      fsFieldRegions = {};
      selectedGroupIndex = null;
      groupOcrResults = {};
      lastGroupBoxes = [];
      drawFsCanvas();
    });
    
    /*************************************
     * fsOcrButton: ユーザー指定フィールド領域に対してOCRを実行する
     *************************************/
    fsOcrButton.addEventListener('click', function() {
      ocrOutput.textContent = "各領域のOCR処理中…\n";
      const tasks = [];
      for (const field in fsFieldRegions) {
        if (field === "amount" && Array.isArray(fsFieldRegions[field])) {
          let amountPromises = fsFieldRegions[field].map(region => performOCROnField("amount", region));
          tasks.push(
            Promise.all(amountPromises).then(results => {
              let total = results.reduce((sum, text) => {
                let num = parseInt(processAmountField(text), 10);
                return sum + (isNaN(num) ? 0 : num);
              }, 0);
              amountField.value = total;
              ocrOutput.textContent += `amount: ${total}\n`;
            })
          );
        } else {
          tasks.push(
            performOCROnField(field, fsFieldRegions[field]).then(resultText => {
              if (field === "date") {
                resultText = processDateField(resultText);
                dateField.value = resultText;
              } else if (field === "payee") {
                payeeField.value = resultText;
              } else if (field === "description") {
                descriptionField.value = resultText;
              }
              ocrOutput.textContent += `${field}: ${resultText}\n`;
            })
          );
        }
      }
      Promise.all(tasks).then(() => {
        ocrOutput.textContent += "全領域のOCR処理完了。";
      });
    });
    
    /*************************************
     * ocrWholeButton: 全体OCRを実行し、グループ化して赤枠情報を算出・保存する
     * スクリーン２遷移時に自動実行される
     *************************************/
    ocrWholeButton.addEventListener('click', async function() {
      ocrOutput.textContent = "全体OCR実行中...\n";
      if (!fsImage.src) {
        console.error("fsImage.src が設定されていません。");
        ocrOutput.textContent += "エラー: 画像が読み込まれていません。\n";
        return;
      }
      const worker = Tesseract.createWorker({ logger: m => console.log("全体OCR:", m) });
      try {
        await worker.load();
        await worker.loadLanguage('jpn');
        await worker.initialize('jpn');
        const { data } = await worker.recognize(fsImage.src);
        lastOcrData = data;
        ocrOutput.textContent += "全体OCR完了。\n";
        // グループ化して赤枠情報を算出・保存する
        displayGroupedText(data);
      } catch (err) {
        console.error("全体OCRエラー:", err);
        ocrOutput.textContent += "エラーが発生しました。\n" + err;
      } finally {
        await worker.terminate();
      }
    });
    
    /*************************************
     * OCRグループ化関連関数
     *************************************/
    
    // completeBBox: バウンディングボックスが不完全な場合に補完する
    function completeBBox(bbox) {
      if (bbox.tl && bbox.tr && bbox.br && bbox.bl) return bbox;
      return { tl: { x: bbox.x0, y: bbox.y0 }, tr: { x: bbox.x1, y: bbox.y0 }, br: { x: bbox.x1, y: bbox.y1 }, bl: { x: bbox.x0, y: bbox.y1 } };
    }
    
    // computeAverageTilt: 単語ごとの左側の傾きの平均を計算する
    function computeAverageTilt(words) {
      let sum = 0, count = 0;
      words.forEach(word => {
        let bbox = completeBBox(word.bbox);
        let tl = bbox.tl, bl = bbox.bl;
        let dx = bl.x - tl.x, dy = bl.y - tl.y;
        if (Math.abs(dx) > 0.001) { sum += Math.atan2(dy, dx); count++; }
      });
      return count > 0 ? sum / count : 0;
    }
    
    // rotatePoint: 点を指定角度で回転させる
    function rotatePoint(point, angle) {
      let cos = Math.cos(angle), sin = Math.sin(angle);
      return { x: point.x * cos - point.y * sin, y: point.x * sin + point.y * cos };
    }
    
    // augmentWordsWithRotatedLeftY: 単語ごとの左側の中心座標と幅を、回転補正して計算する
    function augmentWordsWithRotatedLeftY(words, avgAngle) {
      return words.map(word => {
        let bbox = completeBBox(word.bbox);
        let rtl = rotatePoint(bbox.tl, -avgAngle);
        let rbl = rotatePoint(bbox.bl, -avgAngle);
        let leftYMid = (rtl.y + rbl.y) / 2;
        let thresh = Math.abs(rtl.y - leftYMid);
        let leftXMid = (rtl.x + rbl.x) / 2;
        let rtr = rotatePoint(bbox.tr, -avgAngle);
        let rotatedWidth = Math.abs(rtr.x - rtl.x);
        return Object.assign({}, word, { rotatedLeftYMid: leftYMid, thresh: thresh, rotatedLeftX: leftXMid, rotatedWidth: rotatedWidth });
      });
    }
    
    // groupWordsByLineTilt: 単語を縦方向（左側の中心座標）でグループ化する
    function groupWordsByLineTilt(words) {
      let sorted = words.slice().sort((a, b) => a.rotatedLeftYMid - b.rotatedLeftYMid);
      let groups = [], currentGroup = [];
      sorted.forEach(word => {
        if (currentGroup.length === 0) currentGroup.push(word);
        else {
          let prev = currentGroup[currentGroup.length - 1];
          let tol = Math.min(prev.thresh, word.thresh);
          if (Math.abs(word.rotatedLeftYMid - prev.rotatedLeftYMid) < tol) currentGroup.push(word);
          else { groups.push(currentGroup); currentGroup = [word]; }
        }
      });
      if (currentGroup.length > 0) groups.push(currentGroup);
      return groups;
    }
    
    // groupWordsHorizontally: 各行内の単語を横方向でグループ化する
    function groupWordsHorizontally(words) {
      let sorted = words.slice().sort((a, b) => a.rotatedLeftX - b.rotatedLeftX);
      let totalWidth = sorted.reduce((sum, w) => sum + w.rotatedWidth, 0);
      let avgWidth = sorted.length > 0 ? totalWidth / sorted.length : 0;
      let horizThreshold = 1.5 * avgWidth;
      let groups = [], currentGroup = [];
      sorted.forEach(word => {
        if (currentGroup.length === 0) currentGroup.push(word);
        else {
          let prev = currentGroup[currentGroup.length - 1];
          let prevRight = prev.rotatedLeftX + prev.rotatedWidth;
          let gap = word.rotatedLeftX - prevRight;
          if (gap > horizThreshold) { groups.push(currentGroup); currentGroup = [word]; }
          else currentGroup.push(word);
        }
      });
      if (currentGroup.length > 0) groups.push(currentGroup);
      return groups;
    }
    
    // displayGroupedText: 全体OCR結果から単語をグループ化し、各グループのバウンディングボックス（赤枠）を算出・保存・描画する
    function displayGroupedText(data) {
      drawFsCanvas();
      let avgAngle = computeAverageTilt(data.words);
      let wordsRotated = augmentWordsWithRotatedLeftY(data.words, avgAngle);
      let verticalGroups = groupWordsByLineTilt(wordsRotated);
      let finalGroups = [];
      verticalGroups.forEach(group => {
        let horizontalGroups = groupWordsHorizontally(group);
        horizontalGroups.forEach(subgroup => finalGroups.push(subgroup));
      });
      let groupedText = "\n【グループ化されたOCR結果】\n";
      // 各グループのバウンディングボックスを計算する
      let boxes = finalGroups.map((group, index) => {
        groupedText += `Group ${index + 1}: ${group.map(w => w.text).join(" ")}\n`;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        group.forEach(word => {
          let bbox = completeBBox(word.bbox);
          let rtl = rotatePoint(bbox.tl, -avgAngle);
          let rtr = rotatePoint(bbox.tr, -avgAngle);
          let rbr = rotatePoint(bbox.br, -avgAngle);
          let rbl = rotatePoint(bbox.bl, -avgAngle);
          minX = Math.min(minX, rtl.x, rtr.x, rbr.x, rbl.x);
          minY = Math.min(minY, rtl.y, rtr.y, rbr.y, rbl.y);
          maxX = Math.max(maxX, rtl.x, rtr.x, rbr.x, rbl.x);
          maxY = Math.max(maxY, rtl.y, rtr.y, rbr.y, rbl.y);
        });
        return { x: minX * fsScale, y: minY * fsScale, width: (maxX - minX) * fsScale, height: (maxY - minY) * fsScale };
      });
      ocrOutput.textContent += groupedText;
      console.log(groupedText);
      // 保存：赤枠情報をlastGroupBoxesに保持
      lastGroupBoxes = boxes;
      drawGroupedBoxes(boxes);
    }
    
    // updateGroupedBoxes: スライダー変更などにより、赤枠情報を更新する
    function updateGroupedBoxes() {
      if (!lastOcrData) return;
      drawFsCanvas();
      let avgAngle = computeAverageTilt(lastOcrData.words);
      let wordsRotated = augmentWordsWithRotatedLeftY(lastOcrData.words, avgAngle);
      let verticalGroups = groupWordsByLineTilt(wordsRotated);
      let finalGroups = [];
      verticalGroups.forEach(group => {
        let horizontalGroups = groupWordsHorizontally(group);
        horizontalGroups.forEach(subgroup => finalGroups.push(subgroup));
      });
      let boxes = finalGroups.map(group => {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        group.forEach(word => {
          let bbox = completeBBox(word.bbox);
          let rtl = rotatePoint(bbox.tl, -avgAngle);
          let rtr = rotatePoint(bbox.tr, -avgAngle);
          let rbr = rotatePoint(bbox.br, -avgAngle);
          let rbl = rotatePoint(bbox.bl, -avgAngle);
          minX = Math.min(minX, rtl.x, rtr.x, rbr.x, rbl.x);
          minY = Math.min(minY, rtl.y, rtr.y, rbr.y, rbl.y);
          maxX = Math.max(maxX, rtl.x, rtr.x, rbr.x, rbl.x);
          maxY = Math.max(maxY, rtl.y, rtr.y, rbr.y, rbl.y);
        });
        return { x: minX * fsScale, y: minY * fsScale, width: (maxX - minX) * fsScale, height: (maxY - minY) * fsScale };
      });
      lastGroupBoxes = boxes;
      drawGroupedBoxes(boxes);
    }
    
    // drawGroupedBoxes: 赤枠（グループ枠）を描画する
    function drawGroupedBoxes(boxes) {
      boxes.forEach((box, index) => {
        fsCtx.strokeStyle = "red";
        fsCtx.lineWidth = 3;
        fsCtx.strokeRect(box.x, box.y, box.width, box.height);
        fsCtx.fillStyle = "red";
        fsCtx.font = "16px Arial";
        fsCtx.textBaseline = "top";
        fsCtx.textAlign = "left";
        fsCtx.fillText("Group " + (index + 1), box.x, box.y - 5);
      });
    }
    
    /*************************************
     * performOCROnField: 指定領域に対してOCR処理を実施する
     *************************************/
    function performOCROnField(field, region) {
      return new Promise((resolve, reject) => {
        const originalX = region.x / fsScale;
        const originalY = region.y / fsScale;
        const originalWidth = region.width / fsScale;
        const originalHeight = region.height / fsScale;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = originalWidth;
        tempCanvas.height = originalHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(fsImage, originalX, originalY, originalWidth, originalHeight, 0, 0, originalWidth, originalHeight);
        const croppedDataURL = tempCanvas.toDataURL();
        binarizeImage(croppedDataURL).then(binarizedDataURL => {
          Tesseract.recognize(
            binarizedDataURL,
            'jpn',
            {
              langPath: 'https://tessdata.projectnaptha.com/4.0.0_best/',
              logger: m => console.log(field, m),
              tessedit_char_whitelist: '0123456789年月日-/： ',
              tessedit_pageseg_mode: 6
            }
          ).then(({ data: { text } }) => {
            resolve(replaceCircledNumbers(text).trim());
          }).catch(err => {
            console.error(field, err);
            resolve("エラー");
          });
        }).catch(err => {
          console.error("Binarization error", err);
          resolve("エラー");
        });
      });
    }
    
    /*************************************
     * binarizeImage: 画像を二値化してOCRに適した状態に変換する
     *************************************/
    function binarizeImage(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          const src = cv.imread(canvas);
          const gray = new cv.Mat();
          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
          const binary = new cv.Mat();
          cv.threshold(gray, binary, 128, 255, cv.THRESH_BINARY);
          cv.imshow(canvas, binary);
          const resultDataURL = canvas.toDataURL();
          src.delete(); gray.delete(); binary.delete();
          resolve(resultDataURL);
        };
        img.onerror = function(err) { reject(err); };
        img.src = dataURL;
      });
    }
    
    /*************************************
     * replaceCircledNumbers: 囲み数字を通常の数字に置換する
     *************************************/
    function replaceCircledNumbers(text) {
      const mapping = {
        '⓪': '0', '①': '1', '②': '2', '③': '3', '④': '4',
        '⑤': '5', '⑥': '6', '⑦': '7', '⑧': '8', '⑨': '9',
        '⑩': '10', '⑪': '11', '⑫': '12'
      };
      return text.replace(/[⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫]/g, match => mapping[match] || match);
    }
    
    /*************************************
     * processDateField: 日付フィールド用に和暦→西暦変換を実施
     *************************************/
    function processDateField(text) {
      if (text.includes("令和") || text.includes("平成") || text.includes("昭和")) {
        return convertJapaneseEra(text);
      }
      return text;
    }
    
    /*************************************
     * processAmountField: 金額フィールドから数字以外を削除
     *************************************/
    function processAmountField(text) {
      return text.replace(/\D/g, "");
    }
    
    /*************************************
     * convertJapaneseEra: 和暦を西暦に変換する
     *************************************/
    function convertJapaneseEra(dateStr) {
      const match = dateStr.match(/(令和|平成|昭和)(元|\d+)[年](\d{1,2})[月](\d{1,2})[日]/);
      if (match) {
        const era = match[1];
        const yearPart = match[2];
        const month = match[3];
        const day = match[4];
        let offset = 0;
        if (era === "令和") offset = 2018;
        else if (era === "平成") offset = 1988;
        else if (era === "昭和") offset = 1925;
        const year = (yearPart === "元") ? offset + 1 : parseInt(yearPart, 10) + offset;
        return year + "年" + month + "月" + day + "日";
      }
      return dateStr;
    }
    
    /*************************************
     * 回転・反転処理
     *************************************/
    const rotate90Button = document.getElementById('rotate90Button');
    const rotateNeg90Button = document.getElementById('rotateNeg90Button');
    const flipButton = document.getElementById('flipButton');
    
    rotate90Button.addEventListener('click', function() {
      rotateImage(correctedImage.src, 90).then(newDataURL => {
        correctedImage.src = newDataURL;
        fsImage.src = newDataURL;
      });
    });
    
    rotateNeg90Button.addEventListener('click', function() {
      rotateImage(correctedImage.src, -90).then(newDataURL => {
        correctedImage.src = newDataURL;
        fsImage.src = newDataURL;
      });
    });
    
    flipButton.addEventListener('click', function() {
      flipImage(correctedImage.src).then(newDataURL => {
        correctedImage.src = newDataURL;
        fsImage.src = newDataURL;
      });
    });
    
    // rotateImage: 指定角度で画像を回転
    function rotateImage(dataURL, angle) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          if (angle % 180 !== 0) {
            canvas.width = img.height;
            canvas.height = img.width;
          } else {
            canvas.width = img.width;
            canvas.height = img.height;
          }
          ctx.save();
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.rotate(angle * Math.PI / 180);
          ctx.drawImage(img, -img.width / 2, -img.height / 2);
          ctx.restore();
          resolve(canvas.toDataURL());
        };
        img.onerror = reject;
        img.src = dataURL;
      });
    }
    
    // flipImage: 画像を左右反転する
    function flipImage(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.save();
          ctx.translate(img.width, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(img, 0, 0);
          ctx.restore();
          resolve(canvas.toDataURL());
        };
        img.onerror = reject;
        img.src = dataURL;
      });
    }
    
    /*************************************
     * スライダー処理：OCRグループ化パラメータ更新
     *************************************/
    const groupThresholdSlider = document.getElementById("groupThresholdSlider");
    const groupThresholdValue = document.getElementById("groupThresholdValue");
    groupThresholdSlider.addEventListener("input", () => {
      groupThresholdValue.textContent = groupThresholdSlider.value;
      updateGroupedBoxes();
    });
    
    const overlapThresholdSlider = document.getElementById("overlapThresholdSlider");
    const overlapThresholdValue = document.getElementById("overlapThresholdValue");
    overlapThresholdSlider.addEventListener("input", () => {
      overlapThresholdValue.textContent = overlapThresholdSlider.value;
      updateGroupedBoxes();
    });
    
    /*************************************
     * FSキャンバス上のグループ選択処理
     * クリックした位置に合致するグループがあれば、そのインデックスをselectedGroupIndexにセットし、入力フォームに貼り付け
     *************************************/
    fsCanvas.addEventListener("click", function(e) {
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      const clickX = (e.clientX - rect.left) * scaleX;
      const clickY = (e.clientY - rect.top) * scaleY;
      console.log("Canvas click:", clickX, clickY);
      let foundIndex = null;
      for (let i = 0; i < lastGroupBoxes.length; i++) {
        let box = lastGroupBoxes[i];
        if (clickX >= box.x && clickX <= box.x + box.width &&
            clickY >= box.y && clickY <= box.y + box.height) {
          foundIndex = i;
          break;
        }
      }
      if (foundIndex !== null) {
        console.log("Selected group index:", foundIndex);
        selectedGroupIndex = foundIndex;
        drawFsCanvas(); // 赤枠は常に描画、選択グループはオレンジでハイライト
        if (currentInput) {
          pasteOcrResultIntoInput();
        }
      } else {
        console.log("クリック位置に一致するグループ枠がありません。");
        drawFsCanvas();
      }
    });
    
  </script>
</body>
</html>
