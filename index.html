<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>領収書OCRアプリ（全体OCR＋ボックス選択）</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      overscroll-behavior: none;
    }
    h1, h2, h3, p {
      margin-bottom: 10px;
    }
    hr {
      margin: 30px 0;
    }
    /* ① パースペクティブ補正モード用 */
    #pcCanvasContainer, #fsCanvasContainer {
      position: relative;
      display: inline-block;
    }
    #pcCanvas, #fsCanvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      max-width: 100%;
      height: auto;
      touch-action: none;
    }
    .field-group {
      margin-top: 15px;
    }
    label {
      display: inline-block;
      width: 80px;
    }
    input[type="text"] {
      width: 300px;
      padding: 3px;
    }
    button, select {
      margin-top: 10px;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <h1>領収書OCRアプリ</h1>
  
  <!-- ① 画像パースペクティブ補正モード -->
  <h2>1. 画像パースペクティブ補正</h2>
  <p>
    ファイルを選択し、画像上で領収書の4隅（左上、右上、右下、左下）の順にクリックしてください。<br>
    （クリックすると赤い円が表示され、順次線で連結されます。）
  </p>
  <input type="file" id="imageInput" accept="image/*">
  <div id="pcCanvasContainer">
    <canvas id="pcCanvas"></canvas>
  </div>
  <br>
  <button id="pcResetButton">ポイントリセット</button>
  <button id="pcApplyButton">補正を実行</button>
  <br>
  <h3>補正結果</h3>
  <img id="correctedImage" alt="Corrected Image" style="border:1px solid #ccc; max-width:100%;">
  <br>
  <button id="loadFsButton">この画像でフィールド選択を開始</button>
  
  <hr>
  
  <!-- ② 領収書各項目のフィールド選択＆OCRモード -->
  <h2>2. 領収書各項目のフィールド選択＆OCR</h2>
  <p>
    補正済み画像を対象に、下記ドロップダウンから項目を選択し、画像上で読み取りたい領域をドラッグまたはタッチで指定してください。<br>
    ※日付、支払先、摘要は単一領域、金額は複数領域の指定が可能です。<br>
    ※全体OCRはすでに実行済みですので、各ボックス内の文字列を抽出して表示します。
  </p>
  <label for="fieldSelector">対象項目:</label>
  <select id="fieldSelector">
    <option value="">--フィールドを選択--</option>
    <option value="date">日付</option>
    <option value="amount">金額</option>
    <option value="payee">支払先</option>
    <option value="description">摘要</option>
  </select>
  <div id="fsCanvasContainer">
    <canvas id="fsCanvas"></canvas>
  </div>
  <br>
  <button id="fsResetButton">フィールドリセット</button>
  <button id="fsOcrButton">選択領域でOCR実行</button>
  <h3>OCR結果</h3>
  <pre id="ocrOutput"></pre>
  
  <div class="field-group">
    <label for="dateField">日付:</label>
    <input type="text" id="dateField" placeholder="OCR結果">
  </div>
  <div class="field-group">
    <label for="amountField">金額:</label>
    <input type="text" id="amountField" placeholder="OCR結果">
  </div>
  <div class="field-group">
    <label for="payeeField">支払先:</label>
    <input type="text" id="payeeField" placeholder="OCR結果">
  </div>
  <div class="field-group">
    <label for="descriptionField">摘要:</label>
    <input type="text" id="descriptionField" placeholder="OCR結果">
  </div>
  
  <!-- ライブラリ読み込み -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@6.0.0/dist/tesseract.min.js"></script>
  <script async src="https://docs.opencv.org/3.4.0/opencv.js" onload="onOpenCvReady();"></script>
  
  <script>
    let pcScale = 1; // pcCanvas用のスケール
    let fsScale = 1; // fsCanvas用のスケール
    let globalHocr = null; // 全体OCR結果（hOCR形式）
    
    /*==============================
      ① 画像パースペクティブ補正モード
    ==============================*/
    let pcPoints = [];  // 4点（{x, y}）
    const pcCanvas = document.getElementById('pcCanvas');
    const pcCtx = pcCanvas.getContext('2d');
    let pcImage = new Image();
    
    const imageInput = document.getElementById('imageInput');
    const pcResetButton = document.getElementById('pcResetButton');
    const pcApplyButton = document.getElementById('pcApplyButton');
    const correctedImage = document.getElementById('correctedImage');
    const loadFsButton = document.getElementById('loadFsButton');
    
    imageInput.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = function(event) {
          pcImage.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }
    });
    
    pcImage.onload = function() {
      let maxDisplayWidth = window.innerWidth - 40;
      if (pcImage.width > maxDisplayWidth) {
        pcScale = maxDisplayWidth / pcImage.width;
      } else {
        pcScale = 1;
      }
      pcCanvas.width = pcImage.width * pcScale;
      pcCanvas.height = pcImage.height * pcScale;
      pcPoints = [];
      drawPcCanvas();
    };
    
    function drawPcCanvas() {
      pcCtx.clearRect(0, 0, pcCanvas.width, pcCanvas.height);
      pcCtx.drawImage(pcImage, 0, 0, pcCanvas.width, pcCanvas.height);
      pcPoints.forEach(pt => {
        pcCtx.beginPath();
        pcCtx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);
        pcCtx.fillStyle = "red";
        pcCtx.fill();
      });
      if (pcPoints.length > 1) {
        pcCtx.beginPath();
        pcCtx.moveTo(pcPoints[0].x, pcPoints[0].y);
        for (let i = 1; i < pcPoints.length; i++) {
          pcCtx.lineTo(pcPoints[i].x, pcPoints[i].y);
        }
        pcCtx.strokeStyle = "red";
        pcCtx.lineWidth = 2;
        pcCtx.stroke();
      }
    }
    
    pcCanvas.addEventListener('click', function(e) {
      if (pcPoints.length >= 4) return;
      const rect = pcCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      pcPoints.push({ x, y });
      drawPcCanvas();
    });
    
    pcResetButton.addEventListener('click', function() {
      pcPoints = [];
      drawPcCanvas();
    });
    
    function onOpenCvReady() {
      console.log("OpenCV.js is ready.");
    }
    
    pcApplyButton.addEventListener('click', function() {
      if (pcPoints.length < 4) {
        alert("4つの角を選択してください。");
        return;
      }
      const widthTop = distance(pcPoints[0], pcPoints[1]);
      const widthBottom = distance(pcPoints[3], pcPoints[2]);
      const maxWidth = Math.max(widthTop, widthBottom);
      const heightLeft = distance(pcPoints[0], pcPoints[3]);
      const heightRight = distance(pcPoints[1], pcPoints[2]);
      const maxHeight = Math.max(heightLeft, heightRight);
      
      let srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        pcPoints[0].x, pcPoints[0].y,
        pcPoints[1].x, pcPoints[1].y,
        pcPoints[2].x, pcPoints[2].y,
        pcPoints[3].x, pcPoints[3].y
      ]);
      let dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        0, 0,
        maxWidth, 0,
        maxWidth, maxHeight,
        0, maxHeight
      ]);
      
      let srcMat = cv.imread(pcCanvas);
      let dstMat = new cv.Mat();
      let M = cv.getPerspectiveTransform(srcPts, dstPts);
      let dsize = new cv.Size(maxWidth, maxHeight);
      cv.warpPerspective(srcMat, dstMat, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
      
      let tempCanvas = document.createElement('canvas');
      tempCanvas.width = maxWidth;
      tempCanvas.height = maxHeight;
      cv.imshow(tempCanvas, dstMat);
      correctedImage.src = tempCanvas.toDataURL();
      
      srcMat.delete(); dstMat.delete(); srcPts.delete(); dstPts.delete(); M.delete();
      
      fsImage.src = correctedImage.src;
    });
    
    function distance(p1, p2) {
      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }
    
    loadFsButton.addEventListener('click', function() {
      if (!correctedImage.src) {
        alert("まず、補正を実行してください。");
        return;
      }
      fsImage.src = correctedImage.src;
    });
    
    /*==============================
      ② 領収書各項目のフィールド選択＆OCRモード
    ==============================*/
    let fsImage = new Image();
    const fsCanvas = document.getElementById('fsCanvas');
    const fsCtx = fsCanvas.getContext('2d');
    let fsFieldRegions = {};  // 例: { date: {x,y,width,height}, amount: [ {x,y,width,height}, ... ], ... }
    
    const fieldSelector = document.getElementById('fieldSelector');
    const fsResetButton = document.getElementById('fsResetButton');
    const fsOcrButton = document.getElementById('fsOcrButton');
    const ocrOutput = document.getElementById('ocrOutput');
    const dateField = document.getElementById('dateField');
    const amountField = document.getElementById('amountField');
    const payeeField = document.getElementById('payeeField');
    const descriptionField = document.getElementById('descriptionField');
    
    fsImage.onload = function() {
      let maxDisplayWidth = window.innerWidth - 40;
      if (fsImage.width > maxDisplayWidth) {
        fsScale = maxDisplayWidth / fsImage.width;
      } else {
        fsScale = 1;
      }
      fsCanvas.width = fsImage.width * fsScale;
      fsCanvas.height = fsImage.height * fsScale;
      fsFieldRegions = {};
      drawFsCanvas();
      // 全体OCRをhOCR形式で実行して保存
      Tesseract.recognize(fsImage, 'jpn', { outputFormat: 'hocr', logger: m => console.log("全体OCR", m) })
        .then(result => {
          globalHocr = result.data.hocr;
          console.log("全体OCR結果取得完了");
        })
        .catch(err => {
          console.error("全体OCRエラー", err);
        });
    };
    
    function drawFsCanvas() {
      fsCtx.clearRect(0, 0, fsCanvas.width, fsCanvas.height);
      fsCtx.drawImage(fsImage, 0, 0, fsCanvas.width, fsCanvas.height);
      for (const field in fsFieldRegions) {
        if (field === "amount" && Array.isArray(fsFieldRegions[field])) {
          fsFieldRegions[field].forEach(region => {
            fsCtx.strokeStyle = "red";
            fsCtx.lineWidth = 2;
            fsCtx.strokeRect(region.x, region.y, region.width, region.height);
            fsCtx.fillStyle = "rgba(255,255,255,0.7)";
            fsCtx.fillRect(region.x, region.y - 20, 60, 20);
            fsCtx.fillStyle = "red";
            fsCtx.font = "14px Arial";
            fsCtx.fillText(field, region.x + 2, region.y - 5);
          });
        } else {
          const r = fsFieldRegions[field];
          fsCtx.strokeStyle = "red";
          fsCtx.lineWidth = 2;
          fsCtx.strokeRect(r.x, r.y, r.width, r.height);
          fsCtx.fillStyle = "rgba(255,255,255,0.7)";
          fsCtx.fillRect(r.x, r.y - 20, 50, 20);
          fsCtx.fillStyle = "red";
          fsCtx.font = "14px Arial";
          fsCtx.fillText(field, r.x + 2, r.y - 5);
        }
      }
    }
    
    // Pointer Events で FSモードのフィールド選択（タッチ・マウス対応）
    let fsIsDrawing = false;
    let fsStartX, fsStartY, fsCurrentX, fsCurrentY;
    
    fsCanvas.addEventListener('pointerdown', function(e) {
      if (!fieldSelector.value) {
        alert("まずは対象項目を選択してください。");
        return;
      }
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      fsStartX = e.clientX - rect.left;
      fsStartY = e.clientY - rect.top;
      fsIsDrawing = true;
    });
    
    fsCanvas.addEventListener('pointermove', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      fsCurrentX = e.clientX - rect.left;
      fsCurrentY = e.clientY - rect.top;
      drawFsCanvas();
      fsCtx.strokeStyle = "blue";
      fsCtx.lineWidth = 2;
      fsCtx.strokeRect(fsStartX, fsStartY, fsCurrentX - fsStartX, fsCurrentY - fsStartY);
    });
    
    fsCanvas.addEventListener('pointerup', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      fsIsDrawing = false;
      const rect = fsCanvas.getBoundingClientRect();
      fsCurrentX = e.clientX - rect.left;
      fsCurrentY = e.clientY - rect.top;
      const x = Math.min(fsStartX, fsCurrentX);
      const y = Math.min(fsStartY, fsCurrentY);
      const width = Math.abs(fsCurrentX - fsStartX);
      const height = Math.abs(fsCurrentY - fsStartY);
      if (width === 0 || height === 0) return;
      const field = fieldSelector.value;
      if (field === "amount") {
        if (!fsFieldRegions[field]) {
          fsFieldRegions[field] = [];
        }
        fsFieldRegions[field].push({ x, y, width, height });
      } else {
        fsFieldRegions[field] = { x, y, width, height };
      }
      drawFsCanvas();
    });
    
    fsResetButton.addEventListener('click', function() {
      fsFieldRegions = {};
      drawFsCanvas();
    });
    
    // globalHocr 変数に全体OCRのhOCR結果が保存される
    let globalHocr = null;
    
    // FS OCR: 各フィールド領域ごとに、globalHocrからテキスト抽出
    fsOcrButton.addEventListener('click', function() {
      if (!globalHocr) {
        alert("全体OCRがまだ完了していません。少々お待ちください。");
        return;
      }
      ocrOutput.textContent = "各領域のOCR処理中…\n";
      const tasks = [];
      for (const field in fsFieldRegions) {
        if (field === "amount" && Array.isArray(fsFieldRegions[field])) {
          let amountTexts = fsFieldRegions[field].map(region => extractTextFromHocr(region));
          tasks.push(
            Promise.all(amountTexts).then(results => {
              let total = results.reduce((sum, text) => {
                let num = parseInt(processAmountField(text), 10);
                return sum + (isNaN(num) ? 0 : num);
              }, 0);
              amountField.value = total;
              ocrOutput.textContent += `amount: ${total}\n`;
            })
          );
        } else {
          tasks.push(
            extractTextFromHocr(fsFieldRegions[field]).then(resultText => {
              if (field === "date") {
                resultText = processDateField(resultText);
                dateField.value = resultText;
              } else if (field === "payee") {
                payeeField.value = resultText;
              } else if (field === "description") {
                descriptionField.value = resultText;
              }
              ocrOutput.textContent += `${field}: ${resultText}\n`;
            })
          );
        }
      }
      Promise.all(tasks).then(() => {
        ocrOutput.textContent += "全領域のOCR処理完了。";
      });
    });
    
    // hOCRから、指定領域（fsCanvas座標→画像座標に変換）に含まれる単語を抽出する関数
    function extractTextFromHocr(region) {
      return new Promise((resolve, reject) => {
        if (!globalHocr) {
          resolve("");
          return;
        }
        // fsCanvasは画像がfsScaleで表示されているので、元画像座標に戻す
        const scaleFactor = 1 / fsScale;
        const rx = region.x * scaleFactor;
        const ry = region.y * scaleFactor;
        const rwidth = region.width * scaleFactor;
        const rheight = region.height * scaleFactor;
        let parser = new DOMParser();
        let hocrDoc = parser.parseFromString(globalHocr, "text/html");
        let words = hocrDoc.getElementsByClassName("ocrx_word");
        let extractedWords = [];
        for (let i = 0; i < words.length; i++) {
          let span = words[i];
          let title = span.getAttribute("title");
          // titleに "bbox" が含まれるはず
          let bboxMatch = title.match(/bbox (\d+) (\d+) (\d+) (\d+)/);
          if (bboxMatch) {
            let x1 = parseInt(bboxMatch[1]);
            let y1 = parseInt(bboxMatch[2]);
            let x2 = parseInt(bboxMatch[3]);
            let y2 = parseInt(bboxMatch[4]);
            // 判定：単語のbboxが選択領域に重なっているか（簡易的な判定）
            if (x2 >= rx && x1 <= rx + rwidth && y2 >= ry && y1 <= ry + rheight) {
              extractedWords.push(span.textContent);
            }
          }
        }
        resolve(extractedWords.join(" "));
      });
    }
    
    function processDateField(text) {
      if (text.includes("令和") || text.includes("平成") || text.includes("昭和")) {
        return convertJapaneseEra(text);
      }
      return text;
    }
    
    function processAmountField(text) {
      return text.replace(/\D/g, "");
    }
    
    function convertJapaneseEra(dateStr) {
      let match = dateStr.match(/(令和|平成|昭和)(元|\d+)[年](\d{1,2})[月](\d{1,2})[日]/);
      if (match) {
        let era = match[1];
        let yearPart = match[2];
        let month = match[3];
        let day = match[4];
        let offset = 0;
        if (era === "令和") offset = 2018;
        else if (era === "平成") offset = 1988;
        else if (era === "昭和") offset = 1925;
        let year;
        if (yearPart === "元") {
          year = offset + 1;
        } else {
          year = parseInt(yearPart, 10) + offset;
        }
        return year + "年" + month + "月" + day + "日";
      }
      return dateStr;
    }
    
    // Pointer Events は FSモードで既に利用済み（上記イベントリスナー参照）
  </script>
</body>
</html>
