<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>領収書OCRアプリ（自動切り出し＋各項目選択・OCR／2値化＋複数金額対応）</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      overscroll-behavior: none; /* スクロール抑制 */
    }
    h1, h2, h3, p {
      margin-bottom: 10px;
    }
    hr {
      margin: 30px 0;
    }
    /* 自動切り出し＆フィールド選択モード用 */
    #pcCanvasContainer, #fsCanvasContainer {
      position: relative;
      display: inline-block;
    }
    #pcCanvas, #fsCanvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      max-width: 100%;
      height: auto;
      touch-action: none;
    }
    .field-group {
      margin-top: 15px;
    }
    label {
      display: inline-block;
      width: 80px;
    }
    input[type="text"] {
      width: 300px;
      padding: 3px;
    }
    button, select {
      margin-top: 10px;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <h1>領収書OCRアプリ</h1>
  
  <!-- ① 自動領収書切り出し＆補正モード -->
  <h2>1. 自動領収書切り出し＆補正</h2>
  <p>
    ファイルを選択すると、画像内の輪郭検出により領収書部分が自動で切り出され、正しい視点に補正されます。
  </p>
  <input type="file" id="imageInput" accept="image/*">
  <div id="pcCanvasContainer">
    <canvas id="pcCanvas"></canvas>
  </div>
  <br>
  <button id="autoCropButton">自動切り出し＆補正を実行</button>
  <br>
  <h3>補正結果</h3>
  <img id="correctedImage" alt="Corrected Image" style="border:1px solid #ccc; max-width:100%;">
  <br>
  <button id="loadFsButton">この画像でフィールド選択を開始</button>
  
  <hr>
  
  <!-- ② 領収書各項目のフィールド選択＆OCRモード -->
  <h2>2. 領収書各項目のフィールド選択＆OCR</h2>
  <p>
    補正済み画像を対象に、下記ドロップダウンから項目を選択し、画像上で読み取りたい領域をドラッグまたはタッチで指定してください。<br>
    ※日付、支払先、摘要は単一領域、金額は複数領域の指定が可能です。<br>
    OCR実行時、不要なスペース除去、日付は和暦→西暦変換、金額は記号除去して各領域の数値の合計を算出します。
  </p>
  <label for="fieldSelector">対象項目:</label>
  <select id="fieldSelector">
    <option value="">--フィールドを選択--</option>
    <option value="date">日付</option>
    <option value="amount">金額</option>
    <option value="payee">支払先</option>
    <option value="description">摘要</option>
  </select>
  <div id="fsCanvasContainer">
    <canvas id="fsCanvas"></canvas>
  </div>
  <br>
  <button id="fsResetButton">フィールドリセット</button>
  <button id="fsOcrButton">選択領域でOCR実行</button>
  <h3>OCR結果</h3>
  <pre id="ocrOutput"></pre>
  
  <div class="field-group">
    <label for="dateField">日付:</label>
    <input type="text" id="dateField" placeholder="OCR結果">
  </div>
  <div class="field-group">
    <label for="amountField">金額:</label>
    <input type="text" id="amountField" placeholder="OCR結果">
  </div>
  <div class="field-group">
    <label for="payeeField">支払先:</label>
    <input type="text" id="payeeField" placeholder="OCR結果">
  </div>
  <div class="field-group">
    <label for="descriptionField">摘要:</label>
    <input type="text" id="descriptionField" placeholder="OCR結果">
  </div>
  
  <!-- ライブラリ読み込み -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@6.0.0/dist/tesseract.min.js"></script>
  <script async src="https://docs.opencv.org/3.4.0/opencv.js" onload="onOpenCvReady();"></script>
  
  <script>
    let pcScale = 1; // pcCanvas用スケール
    let fsScale = 1; // fsCanvas用スケール
    
    /*==============================
      ① 自動領収書切り出し＆補正モード
    ==============================*/
    let pcPoints = []; // （今回は自動抽出なので未使用）
    const pcCanvas = document.getElementById('pcCanvas');
    const pcCtx = pcCanvas.getContext('2d');
    let pcImage = new Image();
    
    const imageInput = document.getElementById('imageInput');
    const autoCropButton = document.getElementById('autoCropButton');
    const correctedImage = document.getElementById('correctedImage');
    const loadFsButton = document.getElementById('loadFsButton');
    
    imageInput.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = function(event) {
          pcImage.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }
    });
    
    pcImage.onload = function() {
      let maxDisplayWidth = window.innerWidth - 40;
      pcScale = (pcImage.width > maxDisplayWidth) ? (maxDisplayWidth / pcImage.width) : 1;
      pcCanvas.width = pcImage.width * pcScale;
      pcCanvas.height = pcImage.height * pcScale;
      pcCtx.clearRect(0, 0, pcCanvas.width, pcCanvas.height);
      pcCtx.drawImage(pcImage, 0, 0, pcCanvas.width, pcCanvas.height);
    };
    
    // 自動切り出し＆補正（改善パラメータ付き）
    function autoCrop() {
      if (!pcImage.src) {
        alert("画像が読み込まれていません。");
        return;
      }
      let srcMat = cv.imread(pcCanvas);
      
      // グレースケール変換
      let gray = new cv.Mat();
      cv.cvtColor(srcMat, gray, cv.COLOR_RGBA2GRAY, 0);
      
      // ガウシアンブラー（カーネルサイズ 7x7）
      let blurred = new cv.Mat();
      cv.GaussianBlur(gray, blurred, new cv.Size(7,7), 0);
      
      // Cannyエッジ検出（閾値 50, 150）
      let edges = new cv.Mat();
      cv.Canny(blurred, edges, 50, 150);
      
      // 輪郭検出
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      
      // 面積が一定以上（例：10000）で、4点近似の輪郭を抽出
      let maxArea = 0;
      let bestContour = null;
      for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let peri = cv.arcLength(cnt, true);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
        if (approx.rows === 4) {
          let area = cv.contourArea(approx);
          if (area > 10000 && area > maxArea) {
            maxArea = area;
            if (bestContour !== null) bestContour.delete();
            bestContour = approx;
          } else {
            approx.delete();
          }
        } else {
          approx.delete();
        }
        cnt.delete();
      }
      hierarchy.delete();
      edges.delete();
      blurred.delete();
      gray.delete();
      
      if (bestContour === null) {
        alert("領収書の輪郭が検出できませんでした。");
        srcMat.delete();
        return;
      }
      
      // 4点を抽出し、左上、右上、右下、左下に整列（簡易的な方法）
      let pts = [];
      for (let i = 0; i < 4; i++) {
        pts.push({ x: bestContour.intAt(i, 0), y: bestContour.intAt(i, 1) });
      }
      bestContour.delete();
      
      pts.sort((a, b) => (a.x + a.y) - (b.x + b.y));
      let tl = pts[0];
      let br = pts[3];
      let remaining = [pts[1], pts[2]];
      remaining.sort((a, b) => a.x - b.x);
      let bl = remaining[0];
      let tr = remaining[1];
      
      let widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
      let widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
      let maxWidth = Math.max(widthA, widthB);
      
      let heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
      let heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
      let maxHeight = Math.max(heightA, heightB);
      
      let srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        tl.x, tl.y,
        tr.x, tr.y,
        br.x, br.y,
        bl.x, bl.y
      ]);
      let dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        0, 0,
        maxWidth - 1, 0,
        maxWidth - 1, maxHeight - 1,
        0, maxHeight - 1
      ]);
      
      let M = cv.getPerspectiveTransform(srcPts, dstPts);
      let dsize = new cv.Size(maxWidth, maxHeight);
      let dstMat = new cv.Mat();
      cv.warpPerspective(srcMat, dstMat, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
      
      let tempCanvas = document.createElement('canvas');
      tempCanvas.width = maxWidth;
      tempCanvas.height = maxHeight;
      cv.imshow(tempCanvas, dstMat);
      let autoCroppedDataURL = tempCanvas.toDataURL();
      
      correctedImage.src = autoCroppedDataURL;
      fsImage.src = autoCroppedDataURL;
      
      srcMat.delete(); dstMat.delete(); srcPts.delete(); dstPts.delete(); M.delete();
    }
    
    autoCropButton.addEventListener('click', autoCrop);
    
    function distance(p1, p2) {
      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }
    
    loadFsButton.addEventListener('click', function() {
      if (!correctedImage.src) {
        alert("まず、補正を実行してください。");
        return;
      }
      fsImage.src = correctedImage.src;
    });
    
    /*==============================
      ② 領収書各項目のフィールド選択＆OCRモード
    ==============================*/
    let fsImage = new Image();
    const fsCanvas = document.getElementById('fsCanvas');
    const fsCtx = fsCanvas.getContext('2d');
    let fsFieldRegions = {}; // 例: { date: {x,y,width,height}, amount: [ {x,y,width,height}, ... ], ... }
    
    const fieldSelector = document.getElementById('fieldSelector');
    const fsResetButton = document.getElementById('fsResetButton');
    const fsOcrButton = document.getElementById('fsOcrButton');
    const ocrOutput = document.getElementById('ocrOutput');
    const dateField = document.getElementById('dateField');
    const amountField = document.getElementById('amountField');
    const payeeField = document.getElementById('payeeField');
    const descriptionField = document.getElementById('descriptionField');
    
    fsImage.onload = function() {
      let maxDisplayWidth = window.innerWidth - 40;
      fsScale = (fsImage.width > maxDisplayWidth) ? (maxDisplayWidth / fsImage.width) : 1;
      fsCanvas.width = fsImage.width * fsScale;
      fsCanvas.height = fsImage.height * fsScale;
      fsFieldRegions = {};
      drawFsCanvas();
    };
    
    function drawFsCanvas() {
      fsCtx.clearRect(0, 0, fsCanvas.width, fsCanvas.height);
      fsCtx.drawImage(fsImage, 0, 0, fsCanvas.width, fsCanvas.height);
      for (const field in fsFieldRegions) {
        if (field === "amount" && Array.isArray(fsFieldRegions[field])) {
          fsFieldRegions[field].forEach(region => {
            fsCtx.strokeStyle = "red";
            fsCtx.lineWidth = 2;
            fsCtx.strokeRect(region.x, region.y, region.width, region.height);
            fsCtx.fillStyle = "rgba(255,255,255,0.7)";
            fsCtx.fillRect(region.x, region.y - 20, 60, 20);
            fsCtx.fillStyle = "red";
            fsCtx.font = "14px Arial";
            fsCtx.fillText(field, region.x + 2, region.y - 5);
          });
        } else {
          const r = fsFieldRegions[field];
          fsCtx.strokeStyle = "red";
          fsCtx.lineWidth = 2;
          fsCtx.strokeRect(r.x, r.y, r.width, r.height);
          fsCtx.fillStyle = "rgba(255,255,255,0.7)";
          fsCtx.fillRect(r.x, r.y - 20, 50, 20);
          fsCtx.fillStyle = "red";
          fsCtx.font = "14px Arial";
          fsCtx.fillText(field, r.x + 2, r.y - 5);
        }
      }
    }
    
    // Pointer Events を使って FSモードのフィールド選択（タッチ・マウス対応）
    let fsIsDrawing = false;
    let fsStartX, fsStartY, fsCurrentX, fsCurrentY;
    
    fsCanvas.addEventListener('pointerdown', function(e) {
      if (!fieldSelector.value) {
        alert("まずは対象項目を選択してください。");
        return;
      }
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      fsStartX = e.clientX - rect.left;
      fsStartY = e.clientY - rect.top;
      fsIsDrawing = true;
    });
    
    fsCanvas.addEventListener('pointermove', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      fsCurrentX = e.clientX - rect.left;
      fsCurrentY = e.clientY - rect.top;
      drawFsCanvas();
      fsCtx.strokeStyle = "blue";
      fsCtx.lineWidth = 2;
      fsCtx.strokeRect(fsStartX, fsStartY, fsCurrentX - fsStartX, fsCurrentY - fsStartY);
    });
    
    fsCanvas.addEventListener('pointerup', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      fsIsDrawing = false;
      const rect = fsCanvas.getBoundingClientRect();
      fsCurrentX = e.clientX - rect.left;
      fsCurrentY = e.clientY - rect.top;
      const x = Math.min(fsStartX, fsCurrentX);
      const y = Math.min(fsStartY, fsCurrentY);
      const width = Math.abs(fsCurrentX - fsStartX);
      const height = Math.abs(fsCurrentY - fsStartY);
      if (width === 0 || height === 0) return;
      const field = fieldSelector.value;
      if (field === "amount") {
        if (!fsFieldRegions[field]) {
          fsFieldRegions[field] = [];
        }
        fsFieldRegions[field].push({ x, y, width, height });
      } else {
        fsFieldRegions[field] = { x, y, width, height };
      }
      drawFsCanvas();
    });
    
    fsResetButton.addEventListener('click', function() {
      fsFieldRegions = {};
      drawFsCanvas();
    });
    
    fsOcrButton.addEventListener('click', function() {
      ocrOutput.textContent = "各領域のOCR処理中…\n";
      const tasks = [];
      for (const field in fsFieldRegions) {
        if (field === "amount" && Array.isArray(fsFieldRegions[field])) {
          let amountPromises = fsFieldRegions[field].map(region => performOCROnField("amount", region));
          tasks.push(
            Promise.all(amountPromises).then(results => {
              let total = results.reduce((sum, text) => {
                let num = parseInt(processAmountField(text), 10);
                return sum + (isNaN(num) ? 0 : num);
              }, 0);
              amountField.value = total;
              ocrOutput.textContent += `amount: ${total}\n`;
            })
          );
        } else {
          tasks.push(
            performOCROnField(field, fsFieldRegions[field])
              .then(resultText => {
                if (field === "date") {
                  resultText = processDateField(resultText);
                  dateField.value = resultText;
                } else if (field === "payee") {
                  payeeField.value = resultText;
                } else if (field === "description") {
                  descriptionField.value = resultText;
                }
                ocrOutput.textContent += `${field}: ${resultText}\n`;
              })
          );
        }
      }
      Promise.all(tasks).then(() => {
        ocrOutput.textContent += "全領域のOCR処理完了。";
      });
    });
    
    function performOCROnField(field, region) {
      return new Promise((resolve, reject) => {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = region.width;
        tempCanvas.height = region.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(fsImage, region.x, region.y, region.width, region.height, 0, 0, region.width, region.height);
        const croppedDataURL = tempCanvas.toDataURL();
        // 2値化処理
        binarizeImage(croppedDataURL).then(binarizedDataURL => {
          Tesseract.recognize(
            binarizedDataURL,
            'jpn',
            {
              langPath: 'https://tessdata.projectnaptha.com/4.0.0_best/',
              logger: m => console.log(field, m),
              tessedit_char_whitelist: '0123456789年月日-/： ',
              tessedit_pageseg_mode: 6
            }
          ).then(({ data: { text } }) => {
            const processedText = replaceCircledNumbers(text).trim();
            resolve(processedText);
          }).catch(err => {
            console.error(field, err);
            resolve("エラー");
          });
        }).catch(err => {
          console.error("Binarization error", err);
          resolve("エラー");
        });
      });
    }
    
    // 画像の2値化処理（グレースケール＋閾値処理）
    function binarizeImage(dataURL) {
      return new Promise((resolve, reject) => {
        let img = new Image();
        img.onload = function() {
          let canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          let ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          let src = cv.imread(canvas);
          let gray = new cv.Mat();
          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
          let binary = new cv.Mat();
          cv.threshold(gray, binary, 128, 255, cv.THRESH_BINARY);
          cv.imshow(canvas, binary);
          let resultDataURL = canvas.toDataURL();
          src.delete(); gray.delete(); binary.delete();
          resolve(resultDataURL);
        };
        img.onerror = function(err) {
          reject(err);
        };
        img.src = dataURL;
      });
    }
    
    function replaceCircledNumbers(text) {
      const mapping = {
        '⓪': '0', '①': '1', '②': '2', '③': '3', '④': '4',
        '⑤': '5', '⑥': '6', '⑦': '7', '⑧': '8', '⑨': '9',
        '⑩': '10', '⑪': '11', '⑫': '12'
      };
      return text.replace(/[⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫]/g, function(match) {
        return mapping[match] || match;
      });
    }
    
    function processDateField(text) {
      if (text.includes("令和") || text.includes("平成") || text.includes("昭和")) {
        return convertJapaneseEra(text);
      }
      return text;
    }
    
    function processAmountField(text) {
      return text.replace(/\D/g, "");
    }
    
    function convertJapaneseEra(dateStr) {
      let match = dateStr.match(/(令和|平成|昭和)(元|\d+)[年](\d{1,2})[月](\d{1,2})[日]/);
      if (match) {
        let era = match[1];
        let yearPart = match[2];
        let month = match[3];
        let day = match[4];
        let offset = 0;
        if (era === "令和") offset = 2018;
        else if (era === "平成") offset = 1988;
        else if (era === "昭和") offset = 1925;
        let year;
        if (yearPart === "元") {
          year = offset + 1;
        } else {
          year = parseInt(yearPart, 10) + offset;
        }
        return year + "年" + month + "月" + day + "日";
      }
      return dateStr;
    }
  </script>
</body>
</html>
