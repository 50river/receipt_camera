<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>領収書OCRアプリ</title>
  <style>
    /* ページ全体の基本レイアウト */
    body { margin: 0; font-family: Arial, sans-serif; background: #f0f0f0; }
    #app { width: 100%; max-width: 600px; margin: 0 auto; background: #fff; min-height: 100vh; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    /* ヘッダー */
    #header { background: #007aff; color: #fff; padding: 10px; text-align: center; }
    /* 各スクリーン */
    .screen { display: none; padding: 10px; }
    .screen.active { display: block; }
    h1, h2, h3, p { margin: 10px 0; }
    hr { margin: 20px 0; }
    /* キャンバスコンテナ */
    #pcCanvasContainer, #fsCanvasContainer {
      position: relative;
      margin: 0 auto;
    }
    /* スクリーン２用：スマホ向け調整 */
    @media (max-width: 600px) {
      #fsCanvasContainer {
        margin-left: 0;      /* 左寄せ */
        margin-right: 20px;  /* 右側に余白を追加 */
      }
    }
    /* キャンバス */
    #pcCanvas, #fsCanvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      display: block;
      width: 100%;
      height: auto;
      touch-action: none;
    }
    /* ボタン */
    button { margin: 10px 5px; font-size: 1.5em; padding: 0.15em 0.25em; }
    /* 補正済み画像 */
    #correctedImage {
      border: 1px solid #ccc;
      max-width: 50%;
      display: block;
      margin: 10px auto;
    }
    /* 入力フィールド */
    .field-group { margin-top: 10px; }
    label { display: inline-block; width: 80px; font-weight: bold; }
    input[type="text"] { width: calc(100% - 90px); padding: 3px; }
    /* 計算式・合計表示エリア */
    .field-label { font-weight: bold; }
    .normal-text { font-weight: normal; }
    /* カスタムプログレスバー */
    #ocrProgressContainer {
      position: relative;
      width: 100%;
      height: 20px;
      background: #ddd;
      margin-bottom: 10px;
    }
    #ocrProgressTop {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0;
      background: #4caf50;
    }
    #ocrProgressBottom {
      position: absolute;
      right: 0;
      top: 0;
      height: 100%;
      width: 0;
      background: #2196f3;
    }
    /* 指示文（FSキャンバス直下） */
    .instruction { margin: 10px 0; font-size: 0.9em; color: #555; }
    /* ダイアログ（計算用：金額項目用） */
    #calcDialog {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border: 1px solid #ccc;
      padding: 20px;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #calcDialog img {
      max-width: 100%;
      max-height: 150px;
      display: block;
      margin-bottom: 10px;
    }
    /* ダイアログ（シンプル版：金額以外用） */
    #simpleDialog {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border: 1px solid #ccc;
      padding: 20px;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #simpleDialog img {
      max-width: 100%;
      max-height: 150px;
      display: block;
      margin-bottom: 10px;
    }
    @media (max-width: 600px) {
      #header { padding: 8px; font-size: 1.2em; }
      button { font-size: 1.2em; padding: 0.1em 0.2em; }
      input[type="text"] { font-size: 1em; }
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- ヘッダー -->
    <div id="header"><h1>領収書OCRアプリ</h1></div>
    
    <!-- スクリーン１：画像切り出し＆補正 -->
    <div id="screen1" class="screen active">
      <h2>画像切り出し＆補正</h2>
      <p>画像ファイルを選択し、クロッピング用の編集枠を調整してください。</p>
      <input type="file" id="imageInput" accept="image/*">
      <div id="pcCanvasContainer"><canvas id="pcCanvas"></canvas></div>
      <button id="autoCropButton">自動切り出し＆補正を実行</button>
      <button id="confirmPointsButton" style="display:none;">ポイント確定</button>
      <h3>補正結果</h3>
      <img id="correctedImage" alt="Corrected Image">
      <div id="transformControls" style="display:none; margin-top:10px;">
        <button id="rotate90Button">Rotate 90°</button>
        <button id="rotateNeg90Button">Rotate -90°</button>
        <button id="flipButton">Flip Horizontally</button>
      </div>
      <br>
      <button id="nextToScreen2">次へ</button>
    </div>
    
    <!-- スクリーン２：フィールド選択＆OCR -->
    <div id="screen2" class="screen">
      <h2>フィールド選択＆OCR</h2>
      <!-- カスタムプログレスバー -->
      <div id="ocrProgressContainer">
        <div id="ocrProgressTop"></div>
        <div id="ocrProgressBottom"></div>
      </div>
      <div id="fsCanvasContainer"><canvas id="fsCanvas"></canvas></div>
      
      <!-- 指示文 -->
      <div class="instruction">
        入力フォームが選択されている状態で、領収書画像上の選択したい赤枠をタッチすると、選択した枠の画像とOCR結果が表示されます。<br>
        金額項目の場合は「＋」「－」を押すと、次に入力するものを足すか引くかを指定でき、「＝」ボタンを押すと最終合計がフォームに反映されます。<br>
        その他の項目の場合は、読み取れた文字を確認修正してOKを押すとその値が入力されます。キャンセルを押すと、枠を選び直すことができます。
      </div>
      
      <!-- 入力フォーム -->
      <div class="field-group">
        <label for="dateField">日付:</label>
        <input type="text" id="dateField" placeholder="OCR結果">
      </div>
      <div class="field-group">
        <label for="amountField">金額:</label>
        <input type="text" id="amountField" placeholder="OCR結果">
      </div>
      <!-- 計算式と合計（ボールド解除） -->
      <div class="field-group">
        <span class="field-label" style="font-weight: normal;">計算式:</span> <span id="amountExpression" class="normal-text"></span>
      </div>
      <div class="field-group">
        <span class="field-label" style="font-weight: normal;">合計:</span> <span id="amountTotalDisplay" class="normal-text"></span>
      </div>
      <div class="field-group">
        <label for="payeeField">支払先:</label>
        <input type="text" id="payeeField" placeholder="OCR結果">
      </div>
      <div class="field-group">
        <label for="descriptionField">摘要:</label>
        <input type="text" id="descriptionField" placeholder="OCR結果">
      </div>
      <div class="field-group">
        <label for="noteField">備考:</label>
        <input type="text" id="noteField" placeholder="OCR結果">
      </div>
      
      <button id="fsResetButton">フィールドリセット</button>
      <button id="ocrWholeButton">全体OCR実行</button>
      <button id="backToScreen1">戻る</button>
    </div>
  </div>
  
  <!-- ダイアログ（計算用：金額項目用） -->
  <div id="calcDialog">
    <div>
      <img id="calcDialogImage" src="" style="max-width:100%; max-height:150px; display:block; margin-bottom:10px;">
    </div>
    <div>
      <label>数値:</label>
      <input type="text" id="calcDialogValue" />
    </div>
    <div style="margin-top:10px;">
      <button id="calcDialogPlus">＋</button>
      <button id="calcDialogMinus">－</button>
      <button id="calcDialogEqual">＝</button>
      <button id="calcDialogCancel">キャンセル</button>
    </div>
  </div>
  
  <!-- ダイアログ（シンプル版：金額以外用） -->
  <div id="simpleDialog">
    <div>
      <img id="simpleDialogImage" src="" style="max-width:100%; max-height:150px; display:block; margin-bottom:10px;">
    </div>
    <div>
      <label>数値:</label>
      <input type="text" id="simpleDialogValue" />
    </div>
    <div style="margin-top:10px;">
      <button id="simpleDialogOK">OK</button>
      <button id="simpleDialogCancel">キャンセル</button>
    </div>
  </div>
  
  <!-- ライブラリ読み込み -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <script async src="https://docs.opencv.org/3.4.0/opencv.js"></script>
  
  <script>
    /*************************************
     * グローバル変数
     *************************************/
    let lastGroupBoxes = [];    // 各グループの赤枠情報
    let lastOcrData = null;     // 全体OCR結果
    let groupOcrResults = {};   // 各グループのOCR結果
    let selectedGroupIndex = null; // 単一選択用
    let currentInput = null;    // 現在フォーカス中の入力フォーム
    // calcSequence：金額項目用の計算シーケンス（最初の値、その後「演算子」「値」のペア）
    let calcSequence = [];
    // ダイアログで処理中のグループインデックス（calcDialog用）
    let currentCalcGroupIndex = null;
    // simpleDialog用の現在のグループインデックス
    let currentSimpleGroupIndex = null;
    // 2セグメント用進捗保持変数（上部、下部）
    let segmentProgress = [0, 0];
    
    /*************************************
     * 入力フォームのフォーカス処理
     *************************************/
    ["dateField", "amountField", "payeeField", "descriptionField", "noteField"].forEach(id => {
      const input = document.getElementById(id);
      input.addEventListener("focus", function() {
        currentInput = this;
        if (id === "amountField") {
          calcSequence = [];
          document.getElementById("amountExpression").textContent = "";
          document.getElementById("amountTotalDisplay").textContent = "";
        }
        selectedGroupIndex = null;
      });
    });
    
    /*************************************
     * pasteOcrResultIntoInput
     * 金額以外の場合、選択されたグループのOCR結果を入力フォームに貼り付ける
     *************************************/
    function pasteOcrResultIntoInput() {
      if (currentInput && selectedGroupIndex !== null) {
        if (groupOcrResults.hasOwnProperty(selectedGroupIndex)) {
          currentInput.value = groupOcrResults[selectedGroupIndex];
          currentInput.focus();
          currentInput = null;
        } else {
          performOCROnField("selected", lastGroupBoxes[selectedGroupIndex])
            .then(resultText => {
              resultText = resultText.replace(/\s+/g, "");
              if (currentInput.id === "dateField") { resultText = processDateField(resultText); }
              groupOcrResults[selectedGroupIndex] = resultText;
              currentInput.value = resultText;
              currentInput.focus();
              currentInput = null;
            })
            .catch(err => console.error("OCR error:", err));
        }
      }
    }
    
    /*************************************
     * updateAmountCalculation
     * calcSequence に基づいて計算式と合計金額を更新（※金額項目用）
     *************************************/
    function updateAmountCalculation() {
      if (calcSequence.length === 0) return;
      let total = parseInt(calcSequence[0].value, 10) || 0;
      let expression = calcSequence[0].value;
      for (let i = 1; i < calcSequence.length; i += 2) {
        let opObj = calcSequence[i];
        let numObj = calcSequence[i+1];
        if (!opObj || !numObj) break;
        let op = opObj.operator;
        let num = parseInt(numObj.value, 10) || 0;
        if (op === "+") { total += num; expression += " + " + num; }
        else if (op === "-") { total -= num; expression += " - " + num; }
      }
      document.getElementById("amountExpression").textContent = expression;
      document.getElementById("amountTotalDisplay").textContent = total;
      amountField.value = total;
    }
    
    /*************************************
     * ダイアログ操作（calcDialog：金額項目用）
     *************************************/
    function openCalcDialog(groupIndex) {
      var box = lastGroupBoxes[groupIndex];
      var tempCanvas = document.createElement('canvas');
      tempCanvas.width = box.width / fsScale;
      tempCanvas.height = box.height / fsScale;
      var tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(fsImage, box.x / fsScale, box.y / fsScale, box.width / fsScale, box.height / fsScale, 0, 0, tempCanvas.width, tempCanvas.height);
      document.getElementById('calcDialogImage').src = tempCanvas.toDataURL();
      
      if (groupOcrResults.hasOwnProperty(groupIndex)) {
        document.getElementById('calcDialogValue').value = groupOcrResults[groupIndex];
        showCalcDialog(groupIndex);
      } else {
        performOCROnField("amount", box).then(resultText => {
          var cleaned = processAmountField(resultText.replace(/\s+/g, ""));
          groupOcrResults[groupIndex] = cleaned;
          document.getElementById('calcDialogValue').value = cleaned;
          showCalcDialog(groupIndex);
        });
      }
    }
    
    function showCalcDialog(groupIndex) {
      currentCalcGroupIndex = groupIndex;
      document.getElementById('calcDialog').style.display = 'block';
    }
    
    function closeCalcDialog() {
      document.getElementById('calcDialog').style.display = 'none';
      currentCalcGroupIndex = null;
    }
    
    document.getElementById('calcDialogPlus').addEventListener('click', function() {
      if (currentCalcGroupIndex !== null) {
        let newVal = document.getElementById('calcDialogValue').value;
        groupOcrResults[currentCalcGroupIndex] = newVal;
        if (calcSequence.length === 0) { calcSequence.push({ value: newVal }); }
        calcSequence.push({ operator: "+" });
        updateAmountCalculation();
        closeCalcDialog();
        drawFsCanvas();
      }
    });
    
    document.getElementById('calcDialogMinus').addEventListener('click', function() {
      if (currentCalcGroupIndex !== null) {
        let newVal = document.getElementById('calcDialogValue').value;
        groupOcrResults[currentCalcGroupIndex] = newVal;
        if (calcSequence.length === 0) { calcSequence.push({ value: newVal }); }
        calcSequence.push({ operator: "-" });
        updateAmountCalculation();
        closeCalcDialog();
        drawFsCanvas();
      }
    });
    
    document.getElementById('calcDialogEqual').addEventListener('click', function() {
      if (currentCalcGroupIndex !== null) {
        let newVal = document.getElementById('calcDialogValue').value;
        groupOcrResults[currentCalcGroupIndex] = newVal;
        if (calcSequence.length === 0) { 
          calcSequence.push({ value: newVal }); 
        } else {
          let last = calcSequence[calcSequence.length - 1];
          if (last.operator !== undefined) { calcSequence.push({ value: newVal }); }
        }
        updateAmountCalculation();
        // 複数項目の場合、備考欄に「計算式＝合計」を自動入力
        if(calcSequence.length > 1) {
          let expr = document.getElementById("amountExpression").textContent;
          let total = document.getElementById("amountTotalDisplay").textContent;
          document.getElementById('noteField').value = expr + "＝" + total;
        }
        closeCalcDialog();
        drawFsCanvas();
      }
    });
    
    document.getElementById('calcDialogCancel').addEventListener('click', function() {
      closeCalcDialog();
    });
    
    /*************************************
     * ダイアログ操作（simpleDialog：金額以外用）
     *************************************/
    function openSimpleDialog(groupIndex) {
      var box = lastGroupBoxes[groupIndex];
      var tempCanvas = document.createElement('canvas');
      tempCanvas.width = box.width / fsScale;
      tempCanvas.height = box.height / fsScale;
      var tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(fsImage, box.x / fsScale, box.y / fsScale, box.width / fsScale, box.height / fsScale, 0, 0, tempCanvas.width, tempCanvas.height);
      document.getElementById('simpleDialogImage').src = tempCanvas.toDataURL();
      
      if (groupOcrResults.hasOwnProperty(groupIndex)) {
        document.getElementById('simpleDialogValue').value = groupOcrResults[groupIndex];
        showSimpleDialog(groupIndex);
      } else {
        performOCROnField("nonAmount", box).then(resultText => {
          var cleaned = resultText.replace(/\s+/g, "");
          groupOcrResults[groupIndex] = cleaned;
          document.getElementById('simpleDialogValue').value = cleaned;
          showSimpleDialog(groupIndex);
        });
      }
    }
    
    function showSimpleDialog(groupIndex) {
      currentSimpleGroupIndex = groupIndex;
      document.getElementById('simpleDialog').style.display = 'block';
    }
    
    function closeSimpleDialog() {
      document.getElementById('simpleDialog').style.display = 'none';
      currentSimpleGroupIndex = null;
    }
    
    document.getElementById('simpleDialogOK').addEventListener('click', function() {
      if (currentSimpleGroupIndex !== null) {
        let newVal = document.getElementById('simpleDialogValue').value;
        groupOcrResults[currentSimpleGroupIndex] = newVal;
        if (currentInput) {
          currentInput.value = newVal;
          currentInput.focus();
          currentInput = null;
        }
        closeSimpleDialog();
        drawFsCanvas();
      }
    });
    
    document.getElementById('simpleDialogCancel').addEventListener('click', function() {
      closeSimpleDialog();
    });
    
    /*************************************
     * showScreen: 画面遷移処理
     * 「戻る」ボタン押下時は前回のOCR結果・枠情報・プログレスバーをリセット
     *************************************/
    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(screen => { 
        screen.classList.toggle('active', screen.id === screenId); 
      });
      window.scrollTo(0, 0);
      if (screenId === 'screen1') {
        // 前回のFSの枠情報・OCR結果をクリア
        lastGroupBoxes = [];
        groupOcrResults = {};
        lastOcrData = null;
        segmentProgress = [0, 0];
        updateCustomProgressBar();
        drawPcCanvasWithPoints();
      }
      if (screenId === 'screen2') { 
        drawFsCanvas(); 
        ocrWholeButton.click(); 
      }
    }
    
    document.getElementById('nextToScreen2').addEventListener('click', function() {
      if (!correctedImage.src) { alert("補正結果画像がありません。"); return; }
      showScreen('screen2');
    });
    
    document.getElementById('backToScreen1').addEventListener('click', function() {
      showScreen('screen1');
    });
    
    /*************************************
     * PCモード：画像切り出し＆補正処理
     *************************************/
    let pcScale = 1;
    let detectedPoints = [];
    let draggingPointIndex = -1;
    const AREA_THRESHOLD = 10000;
    const pcCanvas = document.getElementById('pcCanvas');
    const pcCtx = pcCanvas.getContext('2d');
    let pcImage = new Image();
    
    const imageInput = document.getElementById('imageInput');
    const autoCropButton = document.getElementById('autoCropButton');
    const confirmPointsButton = document.getElementById('confirmPointsButton');
    const correctedImage = document.getElementById('correctedImage');
    const transformControls = document.getElementById('transformControls');
    
    imageInput.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const reader = new FileReader();
        reader.onload = event => { pcImage.src = event.target.result; };
        reader.readAsDataURL(e.target.files[0]);
      }
    });
    
    pcImage.onload = function() {
      const maxDisplayWidth = window.innerWidth - 40;
      pcScale = (pcImage.width > maxDisplayWidth) ? (maxDisplayWidth / pcImage.width) : 1;
      pcCanvas.width = pcImage.width * pcScale;
      pcCanvas.height = pcImage.height * pcScale;
      pcCtx.clearRect(0, 0, pcCanvas.width, pcCanvas.height);
      pcCtx.drawImage(pcImage, 0, 0, pcCanvas.width, pcCanvas.height);
      detectedPoints = [];
      confirmPointsButton.style.display = "none";
      transformControls.style.display = "none";
    };
    
    /*************************************
     * autoCrop: 画像から自動で4点検出してpcCanvasに描画
     *************************************/
    function autoCrop() {
      if (!pcImage.src) { alert("画像が読み込まれていません。"); return; }
      const srcMat = cv.imread(pcCanvas);
      const gray = new cv.Mat();
      cv.cvtColor(srcMat, gray, cv.COLOR_RGBA2GRAY, 0);
      const blurred = new cv.Mat();
      cv.GaussianBlur(gray, blurred, new cv.Size(7, 7), 0);
      const edges = new cv.Mat();
      cv.Canny(blurred, edges, 50, 150);
      const kernel = cv.Mat.ones(3, 3, cv.CV_8U);
      const dilated = new cv.Mat();
      cv.dilate(edges, dilated, kernel);
      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(dilated, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      
      let maxArea = 0, bestContour = null;
      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        const peri = cv.arcLength(cnt, true);
        const approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
        if (approx.rows === 4) {
          const area = cv.contourArea(approx);
          if (area > AREA_THRESHOLD && area > maxArea) {
            maxArea = area;
            if (bestContour !== null) bestContour.delete();
            bestContour = approx;
          } else { approx.delete(); }
        } else { approx.delete(); }
        cnt.delete();
      }
      hierarchy.delete(); edges.delete(); dilated.delete(); kernel.delete();
      blurred.delete(); gray.delete();
      
      if (bestContour === null) {
        const marginX = pcCanvas.width * 0.1;
        const marginY = pcCanvas.height * 0.1;
        detectedPoints = [
          { x: marginX, y: marginY },
          { x: pcCanvas.width - marginX, y: marginY },
          { x: pcCanvas.width - marginX, y: pcCanvas.height - marginY },
          { x: marginX, y: pcCanvas.height - marginY }
        ];
        drawPcCanvasWithPoints();
        confirmPointsButton.style.display = "inline-block";
        srcMat.delete();
        return;
      }
      
      detectedPoints = [];
      for (let i = 0; i < 4; i++) {
        detectedPoints.push({ x: bestContour.intAt(i, 0), y: bestContour.intAt(i, 1) });
      }
      bestContour.delete();
      detectedPoints = orderPoints(detectedPoints);
      drawPcCanvasWithPoints();
      confirmPointsButton.style.display = "inline-block";
      srcMat.delete();
    }
    
    /*************************************
     * orderPoints: 4点整列
     *************************************/
    function orderPoints(pts) {
      const sumArr = pts.map(p => p.x + p.y);
      const diffArr = pts.map(p => p.x - p.y);
      const tl = pts[sumArr.indexOf(Math.min(...sumArr))];
      const br = pts[sumArr.indexOf(Math.max(...sumArr))];
      const tr = pts[diffArr.indexOf(Math.min(...diffArr))];
      const bl = pts[diffArr.indexOf(Math.max(...diffArr))];
      return [tl, tr, br, bl];
    }
    
    /*************************************
     * drawPcCanvasWithPoints: PCキャンバス描画
     *************************************/
    function drawPcCanvasWithPoints() {
      pcCtx.clearRect(0, 0, pcCanvas.width, pcCanvas.height);
      pcCtx.drawImage(pcImage, 0, 0, pcCanvas.width, pcCanvas.height);
      detectedPoints.forEach(pt => {
        pcCtx.beginPath();
        pcCtx.arc(pt.x, pt.y, 15, 0, 2 * Math.PI);
        pcCtx.fillStyle = "blue";
        pcCtx.fill();
      });
      if (detectedPoints.length === 4) {
        pcCtx.beginPath();
        pcCtx.moveTo(detectedPoints[0].x, detectedPoints[0].y);
        for (let i = 1; i < 4; i++) { pcCtx.lineTo(detectedPoints[i].x, detectedPoints[i].y); }
        pcCtx.closePath();
        pcCtx.strokeStyle = "blue";
        pcCtx.lineWidth = 4;
        pcCtx.stroke();
      }
    }
    
    autoCropButton.addEventListener('click', autoCrop);
    
    /*************************************
     * PCキャンバス上のドラッグ操作
     *************************************/
    pcCanvas.addEventListener('pointerdown', function(e) {
      if (detectedPoints.length !== 4) return;
      e.preventDefault();
      const rect = pcCanvas.getBoundingClientRect();
      const scaleX = pcCanvas.width / rect.width;
      const scaleY = pcCanvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      draggingPointIndex = -1;
      for (let i = 0; i < 4; i++) { if (Math.hypot(detectedPoints[i].x - x, detectedPoints[i].y - y) < 15) { draggingPointIndex = i; break; } }
    });
    
    pcCanvas.addEventListener('pointermove', function(e) {
      if (draggingPointIndex === -1) return;
      e.preventDefault();
      const rect = pcCanvas.getBoundingClientRect();
      const scaleX = pcCanvas.width / rect.width;
      const scaleY = pcCanvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      detectedPoints[draggingPointIndex] = { x, y };
      drawPcCanvasWithPoints();
    });
    
    pcCanvas.addEventListener('pointerup', e => { e.preventDefault(); draggingPointIndex = -1; });
    
    /*************************************
     * confirmPointsButton: 補正画像生成
     *************************************/
    confirmPointsButton.addEventListener('click', function() {
      if (detectedPoints.length !== 4) { alert("4点が設定されていません。"); return; }
      const ptsOriginal = detectedPoints.map(pt => ({ x: pt.x / pcScale, y: pt.y / pcScale }));
      const [tl, tr, br, bl] = orderPoints(ptsOriginal);
      const widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
      const widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
      const maxWidth = Math.max(widthA, widthB);
      const heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
      const heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
      const maxHeight = Math.max(heightA, heightB);
      
      const offCanvas = document.createElement('canvas');
      offCanvas.width = pcImage.width;
      offCanvas.height = pcImage.height;
      const offCtx = offCanvas.getContext('2d');
      offCtx.drawImage(pcImage, 0, 0);
      const srcMat = cv.imread(offCanvas);
      const srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [ tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y ]);
      const dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [ 0, 0, maxWidth - 1, 0, maxWidth - 1, maxHeight - 1, 0, maxHeight - 1 ]);
      const M = cv.getPerspectiveTransform(srcPts, dstPts);
      const dsize = new cv.Size(maxWidth, maxHeight);
      const dstMat = new cv.Mat();
      cv.warpPerspective(srcMat, dstMat, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = maxWidth;
      tempCanvas.height = maxHeight;
      cv.imshow(tempCanvas, dstMat);
      const croppedDataURL = tempCanvas.toDataURL();
      
      rotateImage(croppedDataURL, 90)
        .then(rotatedDataURL => flipImage(rotatedDataURL))
        .then(finalDataURL => {
          correctedImage.src = finalDataURL;
          fsImage.src = finalDataURL;
          transformControls.style.display = "block";
        });
      
      srcMat.delete(); dstMat.delete(); srcPts.delete(); dstPts.delete(); M.delete();
      detectedPoints = [];
      confirmPointsButton.style.display = "none";
    });
    
    /*************************************
     * FSモード：フィールド選択＆OCR処理（対象項目廃止）
     *************************************/
    let fsImage = new Image();
    const fsCanvas = document.getElementById('fsCanvas');
    const fsCtx = fsCanvas.getContext('2d');
    let fsScale = 1;
    let fsFieldRegions = {}; // 金額項目のみ自動登録
    
    const fsResetButton = document.getElementById('fsResetButton');
    const ocrWholeButton = document.getElementById('ocrWholeButton');
    const dateField = document.getElementById('dateField');
    const amountField = document.getElementById('amountField');
    const payeeField = document.getElementById('payeeField');
    const descriptionField = document.getElementById('descriptionField');
    const noteField = document.getElementById('noteField');
    
    fsImage.onload = function() {
      const maxDisplayWidth = window.innerWidth - 40;
      fsScale = (fsImage.width > maxDisplayWidth) ? (maxDisplayWidth / fsImage.width) : 1;
      fsCanvas.width = fsImage.width * fsScale;
      fsCanvas.height = fsImage.height * fsScale;
      fsFieldRegions = {};
      drawFsCanvas();
    };
    
    /*************************************
     * drawFsCanvas: FSキャンバス描画
     *************************************/
    function drawFsCanvas() {
      fsCtx.clearRect(0, 0, fsCanvas.width, fsCanvas.height);
      fsCtx.drawImage(fsImage, 0, 0, fsCanvas.width, fsCanvas.height);
      if (fsFieldRegions["amount"]) {
        fsFieldRegions["amount"].forEach(region => {
          fsCtx.strokeStyle = "red";
          fsCtx.lineWidth = 4;
          fsCtx.strokeRect(region.x, region.y, region.width, region.height);
          fsCtx.fillStyle = "rgba(255,255,255,0.7)";
          fsCtx.fillRect(region.x, region.y - 20, 60, 20);
          fsCtx.fillStyle = "red";
          fsCtx.font = "14px Arial";
          fsCtx.fillText("amount", region.x + 2, region.y - 5);
        });
      }
      if (lastGroupBoxes.length > 0) { drawGroupedBoxes(lastGroupBoxes); }
      if (currentInput && currentInput.id === "amountField") {
        // 金額項目はダイアログで処理するためハイライトは不要
      } else {
        if (selectedGroupIndex !== null && lastGroupBoxes[selectedGroupIndex]) {
          fsCtx.strokeStyle = "orange";
          fsCtx.lineWidth = 4;
          fsCtx.strokeRect(lastGroupBoxes[selectedGroupIndex].x, lastGroupBoxes[selectedGroupIndex].y,
                           lastGroupBoxes[selectedGroupIndex].width, lastGroupBoxes[selectedGroupIndex].height);
        }
      }
    }
    
    /*************************************
     * FSキャンバス上のドラッグ操作
     *************************************/
    let fsIsDrawing = false, fsStartX, fsStartY, fsCurrentX, fsCurrentY;
    fsCanvas.addEventListener('pointerdown', function(e) {
      if (currentInput) return;
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      fsStartX = (e.clientX - rect.left) * scaleX;
      fsStartY = (e.clientY - rect.top) * scaleY;
      fsIsDrawing = true;
    });
    
    fsCanvas.addEventListener('pointermove', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      fsCurrentX = (e.clientX - rect.left) * scaleX;
      fsCurrentY = (e.clientY - rect.top) * scaleY;
      drawFsCanvas();
      fsCtx.strokeStyle = "blue";
      fsCtx.lineWidth = 4;
      fsCtx.strokeRect(fsStartX, fsStartY, fsCurrentX - fsStartX, fsCurrentY - fsStartY);
    });
    
    fsCanvas.addEventListener('pointerup', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      fsIsDrawing = false;
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      fsCurrentX = (e.clientX - rect.left) * scaleX;
      fsCurrentY = (e.clientY - rect.top) * scaleY;
      const x = Math.min(fsStartX, fsCurrentX);
      const y = Math.min(fsStartY, fsCurrentY);
      const width = Math.abs(fsCurrentX - fsStartX);
      const height = Math.abs(fsCurrentY - fsStartY);
      if (width === 0 || height === 0) return;
      let field = "amount";
      if (!fsFieldRegions[field]) fsFieldRegions[field] = [];
      fsFieldRegions[field].push({ x, y, width, height });
      drawFsCanvas();
    });
    
    /*************************************
     * fsResetButton: リセット
     *************************************/
    fsResetButton.addEventListener('click', function() {
      fsFieldRegions = {};
      selectedGroupIndex = null;
      groupOcrResults = {};
      lastGroupBoxes = [];
      calcSequence = [];
      document.getElementById("amountExpression").textContent = "";
      document.getElementById("amountTotalDisplay").textContent = "";
      document.getElementById("noteField").value = "";
      segmentProgress = [0, 0];
      updateCustomProgressBar();
      drawFsCanvas();
    });
    
    /*************************************
     * カスタムプログレスバー更新関数
     *************************************/
    function updateCustomProgressBar() {
      // 上半分の進捗を左側（0～50%）、下半分の進捗を右側（0～50%）に反映
      document.getElementById("ocrProgressTop").style.width = (segmentProgress[0] * 50) + "%";
      document.getElementById("ocrProgressBottom").style.width = (segmentProgress[1] * 50) + "%";
    }
    
    /*************************************
     * ocrWholeButton: 全体OCR実行（2分割OCR＋カスタムプログレスバー）
     *************************************/
    ocrWholeButton.addEventListener('click', async function() {
      segmentProgress = [0, 0];
      updateCustomProgressBar();
      if (!fsImage.src) { console.error("fsImage.src が設定されていません。"); return; }
      let combinedData = await ocrImageInTwoSegments(fsImage);
      updateCustomProgressBar();
      lastOcrData = combinedData;
      displayGroupedText(combinedData);
    });
    
    /*************************************
     * 画像を上下に2分割して並列OCR処理する関数
     *************************************/
    async function ocrImageInTwoSegments(image) {
      // 画像の自然サイズで処理
      let canvas = document.createElement('canvas');
      canvas.width = image.naturalWidth;
      canvas.height = image.naturalHeight;
      let ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0);
      let halfHeight = Math.floor(canvas.height / 2);
      
      let segmentResults = await Promise.all(
        [0, 1].map(async (segIndex) => {
          let segHeight = segIndex === 0 ? halfHeight : (canvas.height - halfHeight);
          let segCanvas = document.createElement('canvas');
          segCanvas.width = canvas.width;
          segCanvas.height = segHeight;
          let segCtx = segCanvas.getContext('2d');
          segCtx.drawImage(canvas, 0, segIndex * halfHeight, canvas.width, segHeight, 0, 0, canvas.width, segHeight);
          let dataURL = segCanvas.toDataURL();
          
          const worker = Tesseract.createWorker({ 
            logger: m => {
              if(m.status==="recognizing text" && m.progress){
                segmentProgress[segIndex] = m.progress;
                updateCustomProgressBar();
              }
            }
          });
          await worker.load();
          await worker.loadLanguage('jpn');
          await worker.initialize('jpn');
          const { data } = await worker.recognize(dataURL);
          await worker.terminate();
          if (segIndex === 1) {
            data.words.forEach(word => {
              word.bbox.y0 += halfHeight;
              word.bbox.y1 += halfHeight;
            });
          }
          return data;
        })
      );
      
      let combinedWords = [];
      segmentResults.forEach(result => {
        combinedWords = combinedWords.concat(result.words);
      });
      return { words: combinedWords };
    }
    
    /*************************************
     * OCRグループ化関連関数
     *************************************/
    function completeBBox(bbox) {
      if (bbox.tl && bbox.tr && bbox.br && bbox.bl) return bbox;
      return { tl: { x: bbox.x0, y: bbox.y0 }, tr: { x: bbox.x1, y: bbox.y0 }, br: { x: bbox.x1, y: bbox.y1 }, bl: { x: bbox.x0, y: bbox.y1 } };
    }
    
    function computeAverageTilt(words) {
      let sum = 0, count = 0;
      words.forEach(word => {
        let bbox = completeBBox(word.bbox);
        let tl = bbox.tl, bl = bbox.bl;
        let dx = bl.x - tl.x, dy = bl.y - tl.y;
        if (Math.abs(dx) > 0.001) { sum += Math.atan2(dy, dx); count++; }
      });
      return count > 0 ? sum / count : 0;
    }
    
    function rotatePoint(point, angle) {
      let cos = Math.cos(angle), sin = Math.sin(angle);
      return { x: point.x * cos - point.y * sin, y: point.x * sin + point.y * cos };
    }
    
    function augmentWordsWithRotatedLeftY(words, avgAngle) {
      return words.map(word => {
        let bbox = completeBBox(word.bbox);
        let rtl = rotatePoint(bbox.tl, -avgAngle);
        let rbl = rotatePoint(bbox.bl, -avgAngle);
        let leftYMid = (rtl.y + rbl.y) / 2;
        let thresh = Math.abs(rtl.y - leftYMid);
        let leftXMid = (rtl.x + rbl.x) / 2;
        let rtr = rotatePoint(bbox.tr, -avgAngle);
        let rotatedWidth = Math.abs(rtr.x - rtl.x);
        return Object.assign({}, word, { rotatedLeftYMid: leftYMid, thresh: thresh, rotatedLeftX: leftXMid, rotatedWidth: rotatedWidth });
      });
    }
    
    function groupWordsByLineTilt(words) {
      let sorted = words.slice().sort((a, b) => a.rotatedLeftYMid - b.rotatedLeftYMid);
      let groups = [], currentGroup = [];
      sorted.forEach(word => {
        if (currentGroup.length === 0) currentGroup.push(word);
        else {
          let prev = currentGroup[currentGroup.length - 1];
          let tol = Math.min(prev.thresh, word.thresh);
          if (Math.abs(word.rotatedLeftYMid - prev.rotatedLeftYMid) < tol) currentGroup.push(word);
          else { groups.push(currentGroup); currentGroup = [word]; }
        }
      });
      if (currentGroup.length > 0) groups.push(currentGroup);
      return groups;
    }
    
    function groupWordsHorizontally(words) {
      let sorted = words.slice().sort((a, b) => a.rotatedLeftX - b.rotatedLeftX);
      let totalWidth = sorted.reduce((sum, w) => sum + w.rotatedWidth, 0);
      let avgWidth = sorted.length > 0 ? totalWidth / sorted.length : 0;
      let horizThreshold = 1.5 * avgWidth;
      let groups = [], currentGroup = [];
      sorted.forEach(word => {
        if (currentGroup.length === 0) currentGroup.push(word);
        else {
          let prev = currentGroup[currentGroup.length - 1];
          let prevRight = prev.rotatedLeftX + prev.rotatedWidth;
          let gap = word.rotatedLeftX - prevRight;
          if (gap > horizThreshold) { groups.push(currentGroup); currentGroup = [word]; }
          else currentGroup.push(word);
        }
      });
      if (currentGroup.length > 0) groups.push(currentGroup);
      return groups;
    }
    
    function displayGroupedText(data) {
      drawFsCanvas();
      let avgAngle = computeAverageTilt(data.words);
      let wordsRotated = augmentWordsWithRotatedLeftY(data.words, avgAngle);
      let verticalGroups = groupWordsByLineTilt(wordsRotated);
      let finalGroups = [];
      verticalGroups.forEach(group => {
        let horizontalGroups = groupWordsHorizontally(group);
        horizontalGroups.forEach(subgroup => finalGroups.push(subgroup));
      });
      let boxes = finalGroups.map((group, index) => {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        group.forEach(word => {
          let bbox = completeBBox(word.bbox);
          let rtl = rotatePoint(bbox.tl, -avgAngle);
          let rtr = rotatePoint(bbox.tr, -avgAngle);
          let rbr = rotatePoint(bbox.br, -avgAngle);
          let rbl = rotatePoint(bbox.bl, -avgAngle);
          minX = Math.min(minX, rtl.x, rtr.x, rbr.x, rbl.x);
          minY = Math.min(minY, rtl.y, rtr.y, rbr.y, rbl.y);
          maxX = Math.max(maxX, rtl.x, rtr.x, rbr.x, rbl.x);
          maxY = Math.max(maxY, rtl.y, rtr.y, rbr.y, rbl.y);
        });
        return { x: minX * fsScale, y: minY * fsScale, width: (maxX - minX) * fsScale, height: (maxY - minY) * fsScale };
      });
      lastGroupBoxes = boxes;
      drawGroupedBoxes(boxes);
    }
    
    function updateGroupedBoxes() {
      if (!lastOcrData) return;
      drawFsCanvas();
      let avgAngle = computeAverageTilt(lastOcrData.words);
      let wordsRotated = augmentWordsWithRotatedLeftY(lastOcrData.words, avgAngle);
      let verticalGroups = groupWordsByLineTilt(wordsRotated);
      let finalGroups = [];
      verticalGroups.forEach(group => {
        let horizontalGroups = groupWordsHorizontally(group);
        horizontalGroups.forEach(subgroup => finalGroups.push(subgroup));
      });
      let boxes = finalGroups.map(group => {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        group.forEach(word => {
          let bbox = completeBBox(word.bbox);
          let rtl = rotatePoint(bbox.tl, -avgAngle);
          let rtr = rotatePoint(bbox.tr, -avgAngle);
          let rbr = rotatePoint(bbox.br, -avgAngle);
          let rbl = rotatePoint(bbox.bl, -avgAngle);
          minX = Math.min(minX, rtl.x, rtr.x, rbr.x, rbl.x);
          minY = Math.min(minY, rtl.y, rtr.y, rbr.y, rbl.y);
          maxX = Math.max(maxX, rtl.x, rtr.x, rbr.x, rbl.x);
          maxY = Math.max(maxY, rtl.y, rtr.y, rbr.y, rbl.y);
        });
        return { x: minX * fsScale, y: minY * fsScale, width: (maxX - minX) * fsScale, height: (maxY - minY) * fsScale };
      });
      lastGroupBoxes = boxes;
      drawGroupedBoxes(boxes);
    }
    
    function drawGroupedBoxes(boxes) {
      boxes.forEach((box, index) => {
        fsCtx.strokeStyle = "red";
        fsCtx.lineWidth = 3;
        fsCtx.strokeRect(box.x, box.y, box.width, box.height);
      });
    }
    
    /*************************************
     * performOCROnField: 高精度OCR実行
     *************************************/
    function performOCROnField(field, region) {
      return new Promise((resolve, reject) => {
        const originalX = region.x / fsScale;
        const originalY = region.y / fsScale;
        const originalWidth = region.width / fsScale;
        const originalHeight = region.height / fsScale;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = originalWidth;
        tempCanvas.height = originalHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(fsImage, originalX, originalY, originalWidth, originalHeight, 0, 0, originalWidth, originalHeight);
        const croppedDataURL = tempCanvas.toDataURL();
        binarizeImage(croppedDataURL).then(binarizedDataURL => {
          Tesseract.recognize(
            binarizedDataURL,
            'jpn',
            {
              langPath: 'https://tessdata.projectnaptha.com/4.0.0_best/',
              logger: m => console.log(field, m),
              tessedit_char_whitelist: '0123456789年月日-/： ',
              tessedit_pageseg_mode: 6
            }
          ).then(({ data: { text } }) => {
            resolve(replaceCircledNumbers(text.replace(/\s+/g, "")).trim());
          }).catch(err => {
            console.error(field, err);
            resolve("エラー");
          });
        }).catch(err => {
          console.error("Binarization error", err);
          resolve("エラー");
        });
      });
    }
    
    /*************************************
     * binarizeImage: 画像二値化
     *************************************/
    function binarizeImage(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          const src = cv.imread(canvas);
          const gray = new cv.Mat();
          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
          const binary = new cv.Mat();
          cv.threshold(gray, binary, 128, 255, cv.THRESH_BINARY);
          cv.imshow(canvas, binary);
          const resultDataURL = canvas.toDataURL();
          src.delete(); gray.delete(); binary.delete();
          resolve(resultDataURL);
        };
        img.onerror = function(err) { reject(err); };
        img.src = dataURL;
      });
    }
    
    /*************************************
     * replaceCircledNumbers: 囲み数字変換
     *************************************/
    function replaceCircledNumbers(text) {
      const mapping = {
        '⓪': '0', '①': '1', '②': '2', '③': '3', '④': '4',
        '⑤': '5', '⑥': '6', '⑦': '7', '⑧': '8', '⑨': '9',
        '⑩': '10', '⑪': '11', '⑫': '12'
      };
      return text.replace(/[⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫]/g, match => mapping[match] || match);
    }
    
    /*************************************
     * processDateField: 和暦→西暦変換
     *************************************/
    function processDateField(text) {
      if (text.includes("令和") || text.includes("平成") || text.includes("昭和")) {
        return convertJapaneseEra(text);
      }
      return text;
    }
    
    /*************************************
     * processAmountField: 数字のみ抽出
     *************************************/
    function processAmountField(text) {
      return text.replace(/\D/g, "");
    }
    
    /*************************************
     * convertJapaneseEra: 和暦→西暦変換
     *************************************/
    function convertJapaneseEra(dateStr) {
      const match = dateStr.match(/(令和|平成|昭和)(元|\d+)[年](\d{1,2})[月](\d{1,2})[日]/);
      if (match) {
        const era = match[1];
        const yearPart = match[2];
        const month = match[3];
        const day = match[4];
        let offset = 0;
        if (era === "令和") offset = 2018;
        else if (era === "平成") offset = 1988;
        else if (era === "昭和") offset = 1925;
        const year = (yearPart === "元") ? offset + 1 : parseInt(yearPart, 10) + offset;
        return year + "年" + month + "月" + day + "日";
      }
      return dateStr;
    }
    
    /*************************************
     * 回転・反転処理
     *************************************/
    const rotate90Button = document.getElementById('rotate90Button');
    const rotateNeg90Button = document.getElementById('rotateNeg90Button');
    const flipButton = document.getElementById('flipButton');
    
    rotate90Button.addEventListener('click', function() {
      rotateImage(correctedImage.src, 90).then(newDataURL => { correctedImage.src = newDataURL; fsImage.src = newDataURL; });
    });
    
    rotateNeg90Button.addEventListener('click', function() {
      rotateImage(correctedImage.src, -90).then(newDataURL => { correctedImage.src = newDataURL; fsImage.src = newDataURL; });
    });
    
    flipButton.addEventListener('click', function() {
      flipImage(correctedImage.src).then(newDataURL => { correctedImage.src = newDataURL; fsImage.src = newDataURL; });
    });
    
    function rotateImage(dataURL, angle) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          if (angle % 180 !== 0) { canvas.width = img.height; canvas.height = img.width; }
          else { canvas.width = img.width; canvas.height = img.height; }
          ctx.save();
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.rotate(angle * Math.PI / 180);
          ctx.drawImage(img, -img.width / 2, -img.height / 2);
          ctx.restore();
          resolve(canvas.toDataURL());
        };
        img.onerror = reject;
        img.src = dataURL;
      });
    }
    
    function flipImage(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement('canvas');
          canvas.width = img.width; canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.save();
          ctx.translate(img.width, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(img, 0, 0);
          ctx.restore();
          resolve(canvas.toDataURL());
        };
        img.onerror = reject;
        img.src = dataURL;
      });
    }
    
    /*************************************
     * FSキャンバス上でのグループ選択処理
     * 入力フォームが選択されている場合、金額項目なら calcDialog、その他は simpleDialog を表示
     *************************************/
    fsCanvas.addEventListener("click", function(e) {
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      const clickX = (e.clientX - rect.left) * scaleX;
      const clickY = (e.clientY - rect.top) * scaleY;
      console.log("Canvas click:", clickX, clickY);
      let foundIndex = null;
      for (let i = 0; i < lastGroupBoxes.length; i++) {
        let box = lastGroupBoxes[i];
        if (clickX >= box.x && clickX <= box.x + box.width &&
            clickY >= box.y && clickY <= box.y + box.height) { foundIndex = i; break; }
      }
      if (foundIndex !== null) {
        if (currentInput && currentInput.id === "amountField") { 
          openCalcDialog(foundIndex); 
        } else { 
          openSimpleDialog(foundIndex); 
        }
      } else {
        console.log("クリック位置に一致するグループ枠がありません。");
        drawFsCanvas();
      }
    });
  </script>
</body>
</html>
