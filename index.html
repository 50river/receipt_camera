<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>領収書OCRアプリ（自動切り出し＋ポイント調整＆各項目選択・OCR／2値化＋複数金額対応）</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      overscroll-behavior: none;
    }
    h1, h2, h3, p {
      margin-bottom: 10px;
    }
    hr {
      margin: 30px 0;
    }
    /* 自動切り出し＆フィールド選択モード用 */
    #pcCanvasContainer, #fsCanvasContainer {
      position: relative;
      display: inline-block;
    }
    #pcCanvas, #fsCanvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      max-width: 100%;
      height: auto;
      touch-action: none;
    }
    .field-group {
      margin-top: 15px;
    }
    label {
      display: inline-block;
      width: 80px;
    }
    input[type="text"] {
      width: 300px;
      padding: 3px;
    }
    button, select {
      margin-top: 10px;
      margin-right: 5px;
    }
    /* 調整中のポイント用 */
    .point {
      position: absolute;
      width: 12px;
      height: 12px;
      background: blue;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <h1>領収書OCRアプリ</h1>
  
  <!-- ① 自動領収書切り出し＆補正モード -->
  <h2>1. 自動領収書切り出し＆補正</h2>
  <p>
    ファイルを選択すると、画像内の輪郭検出により領収書部分が自動で検出され、候補の4点が表示されます。<br>
    必要に応じて各ポイントをドラッグして調整し、【ポイント確定】ボタンを押して切り出しを確定してください。
  </p>
  <input type="file" id="imageInput" accept="image/*">
  <div id="pcCanvasContainer">
    <canvas id="pcCanvas"></canvas>
  </div>
  <br>
  <button id="autoCropButton">自動切り出し＆補正を実行</button>
  <button id="confirmPointsButton" style="display:none;">ポイント確定</button>
  <br>
  <h3>補正結果</h3>
  <img id="correctedImage" alt="Corrected Image" style="border:1px solid #ccc; max-width:100%;">
  <br>
  <button id="loadFsButton">この画像でフィールド選択を開始</button>
  
  <hr>
  
  <!-- ② 領収書各項目のフィールド選択＆OCRモード -->
  <h2>2. 領収書各項目のフィールド選択＆OCR</h2>
  <p>
    補正済み画像を対象に、下記ドロップダウンから項目を選択し、画像上で読み取りたい領域をドラッグまたはタッチで指定してください。<br>
    ※日付、支払先、摘要は単一領域、金額は複数領域の指定が可能です。<br>
    OCR実行時、不要なスペース除去、日付は和暦→西暦変換、金額は数字以外を除去し、各領域の数値の合計を算出します。
  </p>
  <label for="fieldSelector">対象項目:</label>
  <select id="fieldSelector">
    <option value="">--フィールドを選択--</option>
    <option value="date">日付</option>
    <option value="amount">金額</option>
    <option value="payee">支払先</option>
    <option value="description">摘要</option>
  </select>
  <div id="fsCanvasContainer">
    <canvas id="fsCanvas"></canvas>
  </div>
  <br>
  <button id="fsResetButton">フィールドリセット</button>
  <button id="fsOcrButton">選択領域でOCR実行</button>
  <h3>OCR結果</h3>
  <pre id="ocrOutput"></pre>
  
  <div class="field-group">
    <label for="dateField">日付:</label>
    <input type="text" id="dateField" placeholder="OCR結果">
  </div>
  <div class="field-group">
    <label for="amountField">金額:</label>
    <input type="text" id="amountField" placeholder="OCR結果">
  </div>
  <div class="field-group">
    <label for="payeeField">支払先:</label>
    <input type="text" id="payeeField" placeholder="OCR結果">
  </div>
  <div class="field-group">
    <label for="descriptionField">摘要:</label>
    <input type="text" id="descriptionField" placeholder="OCR結果">
  </div>
  
  <!-- ライブラリ読み込み -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@6.0.0/dist/tesseract.min.js"></script>
  <script async src="https://docs.opencv.org/3.4.0/opencv.js" onload="onOpenCvReady();"></script>
  
  <script>
    let pcScale = 1; // pcCanvas用スケール
    let fsScale = 1; // fsCanvas用スケール
    let detectedPoints = []; // 自動検出された4点（元画像座標）
    let draggingPointIndex = -1; // ドラッグ中の点のインデックス
    const AREA_THRESHOLD = 10000;  // 輪郭面積の閾値（必要に応じて調整）
    
    /*==============================
      ① 自動領収書切り出し＆補正モード
    ==============================*/
    const pcCanvas = document.getElementById('pcCanvas');
    const pcCtx = pcCanvas.getContext('2d');
    let pcImage = new Image();
    
    const imageInput = document.getElementById('imageInput');
    const autoCropButton = document.getElementById('autoCropButton');
    const confirmPointsButton = document.getElementById('confirmPointsButton');
    const correctedImage = document.getElementById('correctedImage');
    const loadFsButton = document.getElementById('loadFsButton');
    
    imageInput.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = function(event) {
          pcImage.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }
    });
    
    pcImage.onload = function() {
      let maxDisplayWidth = window.innerWidth - 40;
      pcScale = (pcImage.width > maxDisplayWidth) ? (maxDisplayWidth / pcImage.width) : 1;
      pcCanvas.width = pcImage.width * pcScale;
      pcCanvas.height = pcImage.height * pcScale;
      pcCtx.clearRect(0, 0, pcCanvas.width, pcCanvas.height);
      pcCtx.drawImage(pcImage, 0, 0, pcCanvas.width, pcCanvas.height);
      detectedPoints = [];
      confirmPointsButton.style.display = "none";
    };
    
    // 自動切り出し＆補正：輪郭検出＋モルフォロジー処理＋パースペクティブ変換
    function autoCrop() {
      if (!pcImage.src) {
        alert("画像が読み込まれていません。");
        return;
      }
      let srcMat = cv.imread(pcCanvas);
      
      // グレースケール変換
      let gray = new cv.Mat();
      cv.cvtColor(srcMat, gray, cv.COLOR_RGBA2GRAY, 0);
      
      // ガウシアンブラー（7x7）
      let blurred = new cv.Mat();
      cv.GaussianBlur(gray, blurred, new cv.Size(7,7), 0);
      
      // Cannyエッジ検出（閾値 50, 150）
      let edges = new cv.Mat();
      cv.Canny(blurred, edges, 50, 150);
      
      // 膨張処理でエッジを強調
      let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
      let dilated = new cv.Mat();
      cv.dilate(edges, dilated, kernel);
      
      // 輪郭検出
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(dilated, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      
      let maxArea = 0;
      let bestContour = null;
      for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let peri = cv.arcLength(cnt, true);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
        if (approx.rows === 4) {
          let area = cv.contourArea(approx);
          console.log("Contour " + i + " area:", area);
          if (area > AREA_THRESHOLD && area > maxArea) {
            maxArea = area;
            if (bestContour !== null) bestContour.delete();
            bestContour = approx;
          } else {
            approx.delete();
          }
        } else {
          approx.delete();
        }
        cnt.delete();
      }
      hierarchy.delete();
      edges.delete();
      dilated.delete();
      kernel.delete();
      blurred.delete();
      gray.delete();
      
      if (bestContour === null) {
        alert("領収書の輪郭が検出できませんでした。パラメータを調整してください。");
        srcMat.delete();
        return;
      }
      
      // 検出された4点を取得（元画像座標）
      detectedPoints = [];
      for (let i = 0; i < 4; i++) {
        detectedPoints.push({
          x: bestContour.intAt(i, 0),
          y: bestContour.intAt(i, 1)
        });
      }
      bestContour.delete();
      
      // 整列（簡易的に左上、右上、右下、左下）
      detectedPoints.sort((a, b) => (a.x + a.y) - (b.x + b.y));
      let tl = detectedPoints[0];
      let br = detectedPoints[3];
      let remaining = [detectedPoints[1], detectedPoints[2]];
      remaining.sort((a, b) => a.x - b.x);
      let bl = remaining[0];
      let tr = remaining[1];
      detectedPoints = [tl, tr, br, bl];
      
      console.log("検出された4点:", detectedPoints);
      drawPcCanvasWithPoints();
      confirmPointsButton.style.display = "inline-block";
      
      srcMat.delete();
    }
    
    function drawPcCanvasWithPoints() {
      pcCtx.clearRect(0, 0, pcCanvas.width, pcCanvas.height);
      pcCtx.drawImage(pcImage, 0, 0, pcCanvas.width, pcCanvas.height);
      detectedPoints.forEach(pt => {
        pcCtx.beginPath();
        // 検出された点は元画像座標なので、pcScaleで表示用に調整
        pcCtx.arc(pt.x * pcScale, pt.y * pcScale, 7, 0, 2 * Math.PI);
        pcCtx.fillStyle = "blue";
        pcCtx.fill();
      });
      if (detectedPoints.length === 4) {
        pcCtx.beginPath();
        pcCtx.moveTo(detectedPoints[0].x * pcScale, detectedPoints[0].y * pcScale);
        for (let i = 1; i < 4; i++) {
          pcCtx.lineTo(detectedPoints[i].x * pcScale, detectedPoints[i].y * pcScale);
        }
        pcCtx.closePath();
        pcCtx.strokeStyle = "blue";
        pcCtx.lineWidth = 2;
        pcCtx.stroke();
      }
    }
    
    autoCropButton.addEventListener('click', autoCrop);
    
    // ドラッグでポイント調整
    pcCanvas.addEventListener('pointerdown', function(e) {
      if (detectedPoints.length !== 4) return;
      e.preventDefault();
      const rect = pcCanvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / pcScale;
      const y = (e.clientY - rect.top) / pcScale;
      draggingPointIndex = -1;
      for (let i = 0; i < 4; i++) {
        let pt = detectedPoints[i];
        if (Math.hypot(pt.x - x, pt.y - y) < 10) {
          draggingPointIndex = i;
          break;
        }
      }
    });
    
    pcCanvas.addEventListener('pointermove', function(e) {
      if (draggingPointIndex === -1) return;
      e.preventDefault();
      const rect = pcCanvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / pcScale;
      const y = (e.clientY - rect.top) / pcScale;
      detectedPoints[draggingPointIndex] = { x, y };
      drawPcCanvasWithPoints();
    });
    
    pcCanvas.addEventListener('pointerup', function(e) {
      e.preventDefault();
      draggingPointIndex = -1;
    });
    
    // ポイント確定で最終的なパースペクティブ補正を実行
    confirmPointsButton.addEventListener('click', function() {
      if (detectedPoints.length !== 4) {
        alert("4点が設定されていません。");
        return;
      }
      let tl = detectedPoints[0], tr = detectedPoints[1],
          br = detectedPoints[2], bl = detectedPoints[3];
      
      let widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
      let widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
      let maxWidth = Math.max(widthA, widthB);
      
      let heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
      let heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
      let maxHeight = Math.max(heightA, heightB);
      
      let srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        tl.x, tl.y,
        tr.x, tr.y,
        br.x, br.y,
        bl.x, bl.y
      ]);
      let dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        0, 0,
        maxWidth - 1, 0,
        maxWidth - 1, maxHeight - 1,
        0, maxHeight - 1
      ]);
      
      let srcMat = cv.imread(pcCanvas);
      let dstMat = new cv.Mat();
      let M = cv.getPerspectiveTransform(srcPts, dstPts);
      let dsize = new cv.Size(maxWidth, maxHeight);
      cv.warpPerspective(srcMat, dstMat, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
      
      let tempCanvas = document.createElement('canvas');
      tempCanvas.width = maxWidth;
      tempCanvas.height = maxHeight;
      cv.imshow(tempCanvas, dstMat);
      let croppedDataURL = tempCanvas.toDataURL();
      
      correctedImage.src = croppedDataURL;
      fsImage.src = croppedDataURL;
      
      srcMat.delete(); dstMat.delete(); srcPts.delete(); dstPts.delete(); M.delete();
      
      detectedPoints = [];
      confirmPointsButton.style.display = "none";
    });
    
    /*==============================
      ② 領収書各項目のフィールド選択＆OCRモード
    ==============================*/
    let fsImage = new Image();
    const fsCanvas = document.getElementById('fsCanvas');
    const fsCtx = fsCanvas.getContext('2d');
    let fsFieldRegions = {}; // 例: { date: {x,y,width,height}, amount: [ {x,y,width,height}, ... ], ... }
    
    const fieldSelector = document.getElementById('fieldSelector');
    const fsResetButton = document.getElementById('fsResetButton');
    const fsOcrButton = document.getElementById('fsOcrButton');
    const ocrOutput = document.getElementById('ocrOutput');
    const dateField = document.getElementById('dateField');
    const amountField = document.getElementById('amountField');
    const payeeField = document.getElementById('payeeField');
    const descriptionField = document.getElementById('descriptionField');
    
    fsImage.onload = function() {
      let maxDisplayWidth = window.innerWidth - 40;
      fsScale = (fsImage.width > maxDisplayWidth) ? (maxDisplayWidth / fsImage.width) : 1;
      fsCanvas.width = fsImage.width * fsScale;
      fsCanvas.height = fsImage.height * fsScale;
      fsFieldRegions = {};
      drawFsCanvas();
    };
    
    function drawFsCanvas() {
      fsCtx.clearRect(0, 0, fsCanvas.width, fsCanvas.height);
      fsCtx.drawImage(fsImage, 0, 0, fsCanvas.width, fsCanvas.height);
      for (const field in fsFieldRegions) {
        if (field === "amount" && Array.isArray(fsFieldRegions[field])) {
          fsFieldRegions[field].forEach(region => {
            fsCtx.strokeStyle = "red";
            fsCtx.lineWidth = 2;
            fsCtx.strokeRect(region.x, region.y, region.width, region.height);
            fsCtx.fillStyle = "rgba(255,255,255,0.7)";
            fsCtx.fillRect(region.x, region.y - 20, 60, 20);
            fsCtx.fillStyle = "red";
            fsCtx.font = "14px Arial";
            fsCtx.fillText(field, region.x + 2, region.y - 5);
          });
        } else {
          const r = fsFieldRegions[field];
          fsCtx.strokeStyle = "red";
          fsCtx.lineWidth = 2;
          fsCtx.strokeRect(r.x, r.y, r.width, r.height);
          fsCtx.fillStyle = "rgba(255,255,255,0.7)";
          fsCtx.fillRect(r.x, r.y - 20, 50, 20);
          fsCtx.fillStyle = "red";
          fsCtx.font = "14px Arial";
          fsCtx.fillText(field, r.x + 2, r.y - 5);
        }
      }
    }
    
    // Pointer Events を使って FSモードのフィールド選択（タッチ・マウス対応）
    let fsIsDrawing = false;
    let fsStartX, fsStartY, fsCurrentX, fsCurrentY;
    
    fsCanvas.addEventListener('pointerdown', function(e) {
      if (!fieldSelector.value) {
        alert("まずは対象項目を選択してください。");
        return;
      }
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      fsStartX = e.clientX - rect.left;
      fsStartY = e.clientY - rect.top;
      fsIsDrawing = true;
    });
    
    fsCanvas.addEventListener('pointermove', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      fsCurrentX = e.clientX - rect.left;
      fsCurrentY = e.clientY - rect.top;
      drawFsCanvas();
      fsCtx.strokeStyle = "blue";
      fsCtx.lineWidth = 2;
      fsCtx.strokeRect(fsStartX, fsStartY, fsCurrentX - fsStartX, fsCurrentY - fsStartY);
    });
    
    fsCanvas.addEventListener('pointerup', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      fsIsDrawing = false;
      const rect = fsCanvas.getBoundingClientRect();
      fsCurrentX = e.clientX - rect.left;
      fsCurrentY = e.clientY - rect.top;
      const x = Math.min(fsStartX, fsCurrentX);
      const y = Math.min(fsStartY, fsCurrentY);
      const width = Math.abs(fsCurrentX - fsStartX);
      const height = Math.abs(fsCurrentY - fsStartY);
      if (width === 0 || height === 0) return;
      const field = fieldSelector.value;
      if (field === "amount") {
        if (!fsFieldRegions[field]) {
          fsFieldRegions[field] = [];
        }
        fsFieldRegions[field].push({ x, y, width, height });
      } else {
        fsFieldRegions[field] = { x, y, width, height };
      }
      drawFsCanvas();
    });
    
    fsResetButton.addEventListener('click', function() {
      fsFieldRegions = {};
      drawFsCanvas();
    });
    
    fsOcrButton.addEventListener('click', function() {
      ocrOutput.textContent = "各領域のOCR処理中…\n";
      const tasks = [];
      for (const field in fsFieldRegions) {
        if (field === "amount" && Array.isArray(fsFieldRegions[field])) {
          let amountPromises = fsFieldRegions[field].map(region => performOCROnField("amount", region));
          tasks.push(
            Promise.all(amountPromises).then(results => {
              let total = results.reduce((sum, text) => {
                let num = parseInt(processAmountField(text), 10);
                return sum + (isNaN(num) ? 0 : num);
              }, 0);
              amountField.value = total;
              ocrOutput.textContent += `amount: ${total}\n`;
            })
          );
        } else {
          tasks.push(
            performOCROnField(field, fsFieldRegions[field])
              .then(resultText => {
                if (field === "date") {
                  resultText = processDateField(resultText);
                  dateField.value = resultText;
                } else if (field === "payee") {
                  payeeField.value = resultText;
                } else if (field === "description") {
                  descriptionField.value = resultText;
                }
                ocrOutput.textContent += `${field}: ${resultText}\n`;
              })
          );
        }
      }
      Promise.all(tasks).then(() => {
        ocrOutput.textContent += "全領域のOCR処理完了。";
      });
    });
    
    function performOCROnField(field, region) {
      return new Promise((resolve, reject) => {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = region.width;
        tempCanvas.height = region.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(fsImage, region.x, region.y, region.width, region.height, 0, 0, region.width, region.height);
        const croppedDataURL = tempCanvas.toDataURL();
        // 2値化処理
        binarizeImage(croppedDataURL).then(binarizedDataURL => {
          Tesseract.recognize(
            binarizedDataURL,
            'jpn',
            {
              langPath: 'https://tessdata.projectnaptha.com/4.0.0_best/',
              logger: m => console.log(field, m),
              tessedit_char_whitelist: '0123456789年月日-/： ',
              tessedit_pageseg_mode: 6
            }
          ).then(({ data: { text } }) => {
            const processedText = replaceCircledNumbers(text).trim();
            resolve(processedText);
          }).catch(err => {
            console.error(field, err);
            resolve("エラー");
          });
        }).catch(err => {
          console.error("Binarization error", err);
          resolve("エラー");
        });
      });
    }
    
    // 画像の2値化処理（グレースケール＋閾値処理）
    function binarizeImage(dataURL) {
      return new Promise((resolve, reject) => {
        let img = new Image();
        img.onload = function() {
          let canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          let ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          let src = cv.imread(canvas);
          let gray = new cv.Mat();
          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
          let binary = new cv.Mat();
          cv.threshold(gray, binary, 128, 255, cv.THRESH_BINARY);
          cv.imshow(canvas, binary);
          let resultDataURL = canvas.toDataURL();
          src.delete(); gray.delete(); binary.delete();
          resolve(resultDataURL);
        };
        img.onerror = function(err) {
          reject(err);
        };
        img.src = dataURL;
      });
    }
    
    function replaceCircledNumbers(text) {
      const mapping = {
        '⓪': '0', '①': '1', '②': '2', '③': '3', '④': '4',
        '⑤': '5', '⑥': '6', '⑦': '7', '⑧': '8', '⑨': '9',
        '⑩': '10', '⑪': '11', '⑫': '12'
      };
      return text.replace(/[⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫]/g, function(match) {
        return mapping[match] || match;
      });
    }
    
    function processDateField(text) {
      if (text.includes("令和") || text.includes("平成") || text.includes("昭和")) {
        return convertJapaneseEra(text);
      }
      return text;
    }
    
    function processAmountField(text) {
      return text.replace(/\D/g, "");
    }
    
    function convertJapaneseEra(dateStr) {
      let match = dateStr.match(/(令和|平成|昭和)(元|\d+)[年](\d{1,2})[月](\d{1,2})[日]/);
      if (match) {
        let era = match[1];
        let yearPart = match[2];
        let month = match[3];
        let day = match[4];
        let offset = 0;
        if (era === "令和") offset = 2018;
        else if (era === "平成") offset = 1988;
        else if (era === "昭和") offset = 1925;
        let year;
        if (yearPart === "元") {
          year = offset + 1;
        } else {
          year = parseInt(yearPart, 10) + offset;
        }
        return year + "年" + month + "月" + day + "日";
      }
      return dateStr;
    }
  </script>
</body>
</html>
