<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>領収書OCRアプリ</title>
  <style>
    /* ページ全体の基本レイアウト */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #f0f0f0;
    }
    #app {
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      background: #fff;
      min-height: 100vh;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    /* ヘッダー部分 */
    #header {
      background: #007aff;
      color: #fff;
      padding: 10px;
      text-align: center;
    }
    /* スクリーンの基本スタイル */
    .screen {
      display: none;
      padding: 10px;
    }
    .screen.active {
      display: block;
    }
    h1, h2, h3, p {
      margin: 10px 0;
    }
    hr {
      margin: 20px 0;
    }
    /* キャンバスを含むコンテナ */
    #pcCanvasContainer, #fsCanvasContainer {
      position: relative;
      margin: 0 auto;
    }
    /* キャンバスのスタイル */
    #pcCanvas, #fsCanvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      display: block;
      width: 100%;
      height: auto;
      touch-action: none;
    }
    /* ボタン、ドロップダウンのスタイル */
    button, select {
      margin: 10px 5px;
      font-size: 1.5em;
      padding: 0.15em 0.25em;
    }
    /* 補正結果画像のスタイル */
    #correctedImage {
      border: 1px solid #ccc;
      max-width: 50%;
      display: block;
      margin: 10px auto;
    }
    /* 入力フィールドグループのスタイル */
    .field-group {
      margin-top: 10px;
    }
    label {
      display: inline-block;
      width: 80px;
    }
    input[type="text"] {
      width: calc(100% - 90px);
      padding: 3px;
    }
    /* OCR進捗表示領域（画面上部に配置） */
    #ocrOutput {
      white-space: pre-wrap;
      font-family: sans-serif;
      border: 1px solid #ccc;
      padding: 10px;
      background: #f9f9f9;
      margin-bottom: 10px;
    }
    /* OCRグループ化パラメータ設定領域 */
    #ocrThresholdControls {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #ccc;
    }
    /* レスポンシブ対応 */
    @media (max-width: 600px) {
      #header { padding: 8px; font-size: 1.2em; }
      button, select { font-size: 1.2em; padding: 0.1em 0.2em; }
      input[type="text"] { font-size: 1em; }
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- ヘッダー -->
    <div id="header">
      <h1>領収書OCRアプリ</h1>
    </div>
    
    <!-- スクリーン１：画像切り出し＆補正 -->
    <div id="screen1" class="screen active">
      <h2>画像切り出し＆補正</h2>
      <p>画像ファイルを選択し、クロッピング用の編集枠を調整してください。</p>
      <!-- 画像ファイル選択 -->
      <input type="file" id="imageInput" accept="image/*">
      <!-- 画像表示用キャンバス -->
      <div id="pcCanvasContainer">
        <canvas id="pcCanvas"></canvas>
      </div>
      <button id="autoCropButton">自動切り出し＆補正を実行</button>
      <button id="confirmPointsButton" style="display:none;">ポイント確定</button>
      <h3>補正結果</h3>
      <!-- 補正済み画像表示 -->
      <img id="correctedImage" alt="Corrected Image">
      <div id="transformControls" style="display:none; margin-top:10px;">
        <button id="rotate90Button">Rotate 90°</button>
        <button id="rotateNeg90Button">Rotate -90°</button>
        <button id="flipButton">Flip Horizontally</button>
      </div>
      <br>
      <!-- 次のスクリーンへ -->
      <button id="nextToScreen2">次へ</button>
    </div>
    
    <!-- スクリーン２：フィールド選択＆OCR -->
    <div id="screen2" class="screen">
      <h2>フィールド選択＆OCR</h2>
      
      <!-- OCR進捗表示（画面上部に表示） -->
      <div id="ocrOutput"></div>
      
      <!-- キャンバス表示（OCR済み画像） -->
      <div id="fsCanvasContainer">
        <canvas id="fsCanvas"></canvas>
      </div>
      
      <!-- 入力フォーム（キャンバスの直下に配置） -->
      <div class="field-group">
        <label for="dateField">日付:</label>
        <input type="text" id="dateField" placeholder="OCR結果">
      </div>
      <div class="field-group">
        <label for="amountField">金額:</label>
        <input type="text" id="amountField" placeholder="OCR結果">
      </div>
      <div class="field-group">
        <label for="payeeField">支払先:</label>
        <input type="text" id="payeeField" placeholder="OCR結果">
      </div>
      <div class="field-group">
        <label for="descriptionField">摘要:</label>
        <input type="text" id="descriptionField" placeholder="OCR結果">
      </div>
      
      <!-- 以下、その他のコントロール -->
      <label for="fieldSelector">対象項目:</label>
      <select id="fieldSelector">
        <option value="">--フィールドを選択--</option>
        <option value="date">日付</option>
        <option value="amount">金額</option>
        <option value="payee">支払先</option>
        <option value="description">摘要</option>
      </select>
      <button id="fsResetButton">フィールドリセット</button>
      <button id="fsOcrButton">選択領域でOCR実行</button>
      <button id="ocrWholeButton">全体OCR実行</button>
      <div id="ocrThresholdControls">
        <h3>OCRグループ化パラメータ設定</h3>
        <div style="margin-bottom: 10px;">
          <label for="groupThresholdSlider">
            行グループ化閾値: <span id="groupThresholdValue">10</span>px
          </label>
          <input type="range" id="groupThresholdSlider" min="5" max="50" value="10">
        </div>
        <div>
          <label for="overlapThresholdSlider">
            横方向重なり閾値: <span id="overlapThresholdValue">0.5</span>
          </label>
          <input type="range" id="overlapThresholdSlider" min="0.1" max="1.0" step="0.1" value="0.5">
        </div>
      </div>
      <button id="backToScreen1">戻る</button>
    </div>
  </div>
  
  <!-- ライブラリ読み込み（Tesseract.jsとOpenCV.js） -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <script async src="https://docs.opencv.org/3.4.0/opencv.js"></script>
  
  <script>
    /*************************************
     * グローバル変数
     *
     * lastGroupBoxes: OCR実行後に得られるグループの赤枠の座標情報を保持
     * lastOcrData: 全体OCRの結果データ
     * groupOcrResults: 各グループのOCR結果を保存するオブジェクト
     * selectedGroupIndex: キャンバス上でユーザーが選択したグループのインデックス
     * currentInput: 現在フォーカスされている入力フォーム（OCR結果を貼り付ける対象）
     *************************************/
    let lastGroupBoxes = [];
    let lastOcrData = null;
    let groupOcrResults = {};
    let selectedGroupIndex = null;
    let currentInput = null;
    
    /*************************************
     * 入力フォームのフォーカス処理
     * 新しいフォームにフォーカスすると前のグループ選択をリセットする
     *************************************/
    ["dateField", "amountField", "payeeField", "descriptionField"].forEach(id => {
      const input = document.getElementById(id);
      input.addEventListener("focus", function() {
        currentInput = this;
        // 新しい入力フォームを選択したときは、前のグループ選択をクリア
        selectedGroupIndex = null;
      });
    });
    
    /*************************************
     * pasteOcrResultIntoInput
     * 現在選択されているグループのOCR結果を、現在の入力フォームに貼り付ける。
     * 貼り付け後、currentInputをリセットして次回の貼り付け対象をクリアする。
     *************************************/
    function pasteOcrResultIntoInput() {
      if(currentInput && selectedGroupIndex !== null) {
        if(groupOcrResults.hasOwnProperty(selectedGroupIndex)) {
          currentInput.value = groupOcrResults[selectedGroupIndex];
          currentInput.focus();
          currentInput = null;
        } else {
          performOCROnField("selected", lastGroupBoxes[selectedGroupIndex]).then(resultText => {
            if(currentInput.id === "dateField"){
              resultText = processDateField(resultText);
            }
            groupOcrResults[selectedGroupIndex] = resultText;
            currentInput.value = resultText;
            currentInput.focus();
            currentInput = null;
          }).catch(err => console.error("OCR error:", err));
        }
      }
    }
    
    /*************************************
     * 画面遷移処理 showScreen
     * 画面遷移時に、スクロール位置を常に先頭に戻す。
     * スクリーン2へ遷移時は、自動で全体OCRを開始する。
     *************************************/
    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.toggle('active', screen.id === screenId);
      });
      // 画面上部にスクロールする
      window.scrollTo(0, 0);
      if(screenId === 'screen1') {
        drawPcCanvasWithPoints();
      }
      if(screenId === 'screen2') {
        drawFsCanvas();
        // スクリーン2に遷移したときに自動で全体OCRを開始
        ocrWholeButton.click();
      }
    }
    
    document.getElementById('nextToScreen2').addEventListener('click', function() {
      if (!correctedImage.src) {
        alert("補正結果画像がありません。");
        return;
      }
      showScreen('screen2');
    });
    
    document.getElementById('backToScreen1').addEventListener('click', function() {
      showScreen('screen1');
    });
    
    /*************************************
     * PCモード（画像切り出し＆補正）
     *************************************/
    let pcScale = 1;
    let detectedPoints = [];
    let draggingPointIndex = -1;
    const AREA_THRESHOLD = 10000;
    
    const pcCanvas = document.getElementById('pcCanvas');
    const pcCtx = pcCanvas.getContext('2d');
    let pcImage = new Image();
    
    // 画像ファイル選択時に画像を読み込み、pcCanvasに描画する
    const imageInput = document.getElementById('imageInput');
    const autoCropButton = document.getElementById('autoCropButton');
    const confirmPointsButton = document.getElementById('confirmPointsButton');
    const correctedImage = document.getElementById('correctedImage');
    const transformControls = document.getElementById('transformControls');
    
    imageInput.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const reader = new FileReader();
        reader.onload = event => { pcImage.src = event.target.result; };
        reader.readAsDataURL(e.target.files[0]);
      }
    });
    
    pcImage.onload = function() {
      const maxDisplayWidth = window.innerWidth - 40;
      pcScale = (pcImage.width > maxDisplayWidth) ? (maxDisplayWidth / pcImage.width) : 1;
      pcCanvas.width = pcImage.width * pcScale;
      pcCanvas.height = pcImage.height * pcScale;
      pcCtx.clearRect(0, 0, pcCanvas.width, pcCanvas.height);
      pcCtx.drawImage(pcImage, 0, 0, pcCanvas.width, pcCanvas.height);
      detectedPoints = [];
      confirmPointsButton.style.display = "none";
      transformControls.style.display = "none";
    };
    
    /*************************************
     * autoCrop
     * 画像から自動で4点を検出し、切り出しを実行する
     *************************************/
    function autoCrop() {
      if (!pcImage.src) {
        alert("画像が読み込まれていません。");
        return;
      }
      const srcMat = cv.imread(pcCanvas);
      const gray = new cv.Mat();
      cv.cvtColor(srcMat, gray, cv.COLOR_RGBA2GRAY, 0);
      const blurred = new cv.Mat();
      cv.GaussianBlur(gray, blurred, new cv.Size(7, 7), 0);
      const edges = new cv.Mat();
      cv.Canny(blurred, edges, 50, 150);
      const kernel = cv.Mat.ones(3, 3, cv.CV_8U);
      const dilated = new cv.Mat();
      cv.dilate(edges, dilated, kernel);
      
      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(dilated, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      
      let maxArea = 0, bestContour = null;
      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        const peri = cv.arcLength(cnt, true);
        const approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
        if (approx.rows === 4) {
          const area = cv.contourArea(approx);
          if (area > AREA_THRESHOLD && area > maxArea) {
            maxArea = area;
            if (bestContour !== null) bestContour.delete();
            bestContour = approx;
          } else {
            approx.delete();
          }
        } else {
          approx.delete();
        }
        cnt.delete();
      }
      hierarchy.delete(); edges.delete(); dilated.delete(); kernel.delete();
      blurred.delete(); gray.delete();
      
      // もし輪郭が検出できなければ、画像の端にデフォルトの枠を設定
      if (bestContour === null) {
        const marginX = pcCanvas.width * 0.1;
        const marginY = pcCanvas.height * 0.1;
        detectedPoints = [
          { x: marginX, y: marginY },
          { x: pcCanvas.width - marginX, y: marginY },
          { x: pcCanvas.width - marginX, y: pcCanvas.height - marginY },
          { x: marginX, y: pcCanvas.height - marginY }
        ];
        drawPcCanvasWithPoints();
        confirmPointsButton.style.display = "inline-block";
        srcMat.delete();
        return;
      }
      
      // 検出された4点を保存
      detectedPoints = [];
      for (let i = 0; i < 4; i++) {
        detectedPoints.push({ x: bestContour.intAt(i, 0), y: bestContour.intAt(i, 1) });
      }
      bestContour.delete();
      detectedPoints = orderPoints(detectedPoints);
      drawPcCanvasWithPoints();
      confirmPointsButton.style.display = "inline-block";
      srcMat.delete();
    }
    
    /*************************************
     * orderPoints
     * 4点の座標を整列させ、左上、右上、右下、左下の順に並べ替える
     *************************************/
    function orderPoints(pts) {
      const sumArr = pts.map(p => p.x + p.y);
      const diffArr = pts.map(p => p.x - p.y);
      const tl = pts[sumArr.indexOf(Math.min(...sumArr))];
      const br = pts[sumArr.indexOf(Math.max(...sumArr))];
      const tr = pts[diffArr.indexOf(Math.min(...diffArr))];
      const bl = pts[diffArr.indexOf(Math.max(...diffArr))];
      return [tl, tr, br, bl];
    }
    
    /*************************************
     * drawPcCanvasWithPoints
     * PC用キャンバスに画像と検出された4点、及びその線を描画する
     *************************************/
    function drawPcCanvasWithPoints() {
      pcCtx.clearRect(0, 0, pcCanvas.width, pcCanvas.height);
      pcCtx.drawImage(pcImage, 0, 0, pcCanvas.width, pcCanvas.height);
      detectedPoints.forEach(pt => {
        pcCtx.beginPath();
        pcCtx.arc(pt.x, pt.y, 15, 0, 2 * Math.PI);
        pcCtx.fillStyle = "blue";
        pcCtx.fill();
      });
      if (detectedPoints.length === 4) {
        pcCtx.beginPath();
        pcCtx.moveTo(detectedPoints[0].x, detectedPoints[0].y);
        for (let i = 1; i < 4; i++) {
          pcCtx.lineTo(detectedPoints[i].x, detectedPoints[i].y);
        }
        pcCtx.closePath();
        pcCtx.strokeStyle = "blue";
        pcCtx.lineWidth = 4;
        pcCtx.stroke();
      }
    }
    
    autoCropButton.addEventListener('click', autoCrop);
    
    /*************************************
     * PCキャンバス上での4点操作（ドラッグで移動できる）
     *************************************/
    pcCanvas.addEventListener('pointerdown', function(e) {
      if (detectedPoints.length !== 4) return;
      e.preventDefault();
      const rect = pcCanvas.getBoundingClientRect();
      const scaleX = pcCanvas.width / rect.width;
      const scaleY = pcCanvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      draggingPointIndex = -1;
      for (let i = 0; i < 4; i++) {
        if (Math.hypot(detectedPoints[i].x - x, detectedPoints[i].y - y) < 15) {
          draggingPointIndex = i;
          break;
        }
      }
    });
    
    pcCanvas.addEventListener('pointermove', function(e) {
      if (draggingPointIndex === -1) return;
      e.preventDefault();
      const rect = pcCanvas.getBoundingClientRect();
      const scaleX = pcCanvas.width / rect.width;
      const scaleY = pcCanvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      detectedPoints[draggingPointIndex] = { x, y };
      drawPcCanvasWithPoints();
    });
    
    pcCanvas.addEventListener('pointerup', e => { e.preventDefault(); draggingPointIndex = -1; });
    
    /*************************************
     * confirmPointsButton
     * 検出または調整した4点を元に、元画像から透視変換による切り出しを行う
     *************************************/
    confirmPointsButton.addEventListener('click', function() {
      if (detectedPoints.length !== 4) {
        alert("4点が設定されていません。");
        return;
      }
      const ptsOriginal = detectedPoints.map(pt => ({ x: pt.x / pcScale, y: pt.y / pcScale }));
      const [tl, tr, br, bl] = orderPoints(ptsOriginal);
      
      const widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
      const widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
      const maxWidth = Math.max(widthA, widthB);
      
      const heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
      const heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
      const maxHeight = Math.max(heightA, heightB);
      
      const offCanvas = document.createElement('canvas');
      offCanvas.width = pcImage.width;
      offCanvas.height = pcImage.height;
      const offCtx = offCanvas.getContext('2d');
      offCtx.drawImage(pcImage, 0, 0);
      const srcMat = cv.imread(offCanvas);
      
      const srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        tl.x, tl.y,
        tr.x, tr.y,
        br.x, br.y,
        bl.x, bl.y
      ]);
      const dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        0, 0,
        maxWidth - 1, 0,
        maxWidth - 1, maxHeight - 1,
        0, maxHeight - 1
      ]);
      
      const M = cv.getPerspectiveTransform(srcPts, dstPts);
      const dsize = new cv.Size(maxWidth, maxHeight);
      const dstMat = new cv.Mat();
      cv.warpPerspective(srcMat, dstMat, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = maxWidth;
      tempCanvas.height = maxHeight;
      cv.imshow(tempCanvas, dstMat);
      const croppedDataURL = tempCanvas.toDataURL();
      
      // 画像の回転・反転処理
      rotateImage(croppedDataURL, 90)
        .then(rotatedDataURL => flipImage(rotatedDataURL))
        .then(finalDataURL => {
          correctedImage.src = finalDataURL;
          fsImage.src = finalDataURL;
          transformControls.style.display = "block";
        });
      
      srcMat.delete(); dstMat.delete(); srcPts.delete(); dstPts.delete(); M.delete();
      detectedPoints = [];
      confirmPointsButton.style.display = "none";
    });
    
    /*************************************
     * FSモード（フィールド選択＆OCR）
     *************************************/
    let fsImage = new Image();
    const fsCanvas = document.getElementById('fsCanvas');
    const fsCtx = fsCanvas.getContext('2d');
    let fsScale = 1;
    let fsFieldRegions = {};
    
    // 各種コントロール取得
    const fieldSelector = document.getElementById('fieldSelector');
    const fsResetButton = document.getElementById('fsResetButton');
    const fsOcrButton = document.getElementById('fsOcrButton');
    const ocrWholeButton = document.getElementById('ocrWholeButton');
    // 入力フォーム
    const dateField = document.getElementById('dateField');
    const amountField = document.getElementById('amountField');
    const payeeField = document.getElementById('payeeField');
    const descriptionField = document.getElementById('descriptionField');
    const ocrOutput = document.getElementById('ocrOutput');
    
    fsImage.onload = function() {
      const maxDisplayWidth = window.innerWidth - 40;
      fsScale = (fsImage.width > maxDisplayWidth) ? (maxDisplayWidth / fsImage.width) : 1;
      fsCanvas.width = fsImage.width * fsScale;
      fsCanvas.height = fsImage.height * fsScale;
      fsFieldRegions = {};
      drawFsCanvas();
    };
    
    /*************************************
     * drawFsCanvas
     * FS用キャンバスに画像、ユーザー指定のフィールド枠、グループ枠（赤）、および選択グループ（オレンジ）を描画する
     *************************************/
    function drawFsCanvas() {
      fsCtx.clearRect(0, 0, fsCanvas.width, fsCanvas.height);
      fsCtx.drawImage(fsImage, 0, 0, fsCanvas.width, fsCanvas.height);
      // ユーザー指定のフィールド枠（赤）はフィールドリセットボタンが押されるまでそのまま描画
      for (const field in fsFieldRegions) {
        if (field === "amount" && Array.isArray(fsFieldRegions[field])) {
          fsFieldRegions[field].forEach(region => {
            fsCtx.strokeStyle = "red";
            fsCtx.lineWidth = 4;
            fsCtx.strokeRect(region.x, region.y, region.width, region.height);
            fsCtx.fillStyle = "rgba(255,255,255,0.7)";
            fsCtx.fillRect(region.x, region.y - 20, 60, 20);
            fsCtx.fillStyle = "red";
            fsCtx.font = "14px Arial";
            fsCtx.fillText(field, region.x + 2, region.y - 5);
          });
        } else {
          const r = fsFieldRegions[field];
          fsCtx.strokeStyle = "red";
          fsCtx.lineWidth = 4;
          fsCtx.strokeRect(r.x, r.y, r.width, r.height);
          fsCtx.fillStyle = "rgba(255,255,255,0.7)";
          fsCtx.fillRect(r.x, r.y - 20, 50, 20);
          fsCtx.fillStyle = "red";
          fsCtx.font = "14px Arial";
          fsCtx.fillText(field, r.x + 2, r.y - 5);
        }
      }
      // 常に保持する赤枠のグループ情報（lastGroupBoxes）を描画
      if(lastGroupBoxes.length > 0) {
        drawGroupedBoxes(lastGroupBoxes);
      }
      // 選択中のグループがあればオレンジの枠でハイライト
      if(selectedGroupIndex !== null && lastGroupBoxes[selectedGroupIndex]){
        let box = lastGroupBoxes[selectedGroupIndex];
        fsCtx.strokeStyle = "orange";
        fsCtx.lineWidth = 4;
        fsCtx.strokeRect(box.x, box.y, box.width, box.height);
      }
    }
    
    /*************************************
     * fsFieldRegions:
     * ユーザーが指定したフィールド枠の情報を保持する
     *************************************/
    let fsIsDrawing = false, fsStartX, fsStartY, fsCurrentX, fsCurrentY;
    
    fsCanvas.addEventListener('pointerdown', function(e) {
      // 入力フォームがフォーカス中なら、グループ選択処理を行う
      if(currentInput) return;
      if (!fieldSelector.value) {
        alert("まずは対象項目を選択してください。");
        return;
      }
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      fsStartX = (e.clientX - rect.left) * scaleX;
      fsStartY = (e.clientY - rect.top) * scaleY;
      fsIsDrawing = true;
    });
    
    fsCanvas.addEventListener('pointermove', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      fsCurrentX = (e.clientX - rect.left) * scaleX;
      fsCurrentY = (e.clientY - rect.top) * scaleY;
      drawFsCanvas();
      // 青枠でドラッグ中の矩形を描画
      fsCtx.strokeStyle = "blue";
      fsCtx.lineWidth = 4;
      fsCtx.strokeRect(fsStartX, fsStartY, fsCurrentX - fsStartX, fsCurrentY - fsStartY);
    });
    
    fsCanvas.addEventListener('pointerup', function(e) {
      if (!fsIsDrawing) return;
      e.preventDefault();
      fsIsDrawing = false;
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      fsCurrentX = (e.clientX - rect.left) * scaleX;
      fsCurrentY = (e.clientY - rect.top) * scaleY;
      const x = Math.min(fsStartX, fsCurrentX);
      const y = Math.min(fsStartY, fsCurrentY);
      const width = Math.abs(fsCurrentX - fsStartX);
      const height = Math.abs(fsCurrentY - fsStartY);
      if (width === 0 || height === 0) return;
      const field = fieldSelector.value;
      if (field === "amount") {
        if (!fsFieldRegions[field]) fsFieldRegions[field] = [];
        fsFieldRegions[field].push({ x, y, width, height });
      } else {
        fsFieldRegions[field] = { x, y, width, height };
      }
      drawFsCanvas();
    });
    
    /*************************************
     * fsResetButton
     * フィールドリセット時、ユーザー指定フィールド枠、グループ選択、OCR結果、赤枠情報をクリアする
     *************************************/
    fsResetButton.addEventListener('click', function() {
      fsFieldRegions = {};
      selectedGroupIndex = null;
      groupOcrResults = {};
      lastGroupBoxes = [];
      drawFsCanvas();
    });
    
    /*************************************
     * fsOcrButton
     * ユーザー指定のフィールド領域でOCR処理を行う
     *************************************/
    fsOcrButton.addEventListener('click', function() {
      ocrOutput.textContent = "各領域のOCR処理中…\n";
      const tasks = [];
      for (const field in fsFieldRegions) {
        if (field === "amount" && Array.isArray(fsFieldRegions[field])) {
          let amountPromises = fsFieldRegions[field].map(region => performOCROnField("amount", region));
          tasks.push(
            Promise.all(amountPromises).then(results => {
              let total = results.reduce((sum, text) => {
                let num = parseInt(processAmountField(text), 10);
                return sum + (isNaN(num) ? 0 : num);
              }, 0);
              amountField.value = total;
              ocrOutput.textContent += `amount: ${total}\n`;
            })
          );
        } else {
          tasks.push(
            performOCROnField(field, fsFieldRegions[field]).then(resultText => {
              if (field === "date") {
                resultText = processDateField(resultText);
                dateField.value = resultText;
              } else if (field === "payee") {
                payeeField.value = resultText;
              } else if (field === "description") {
                descriptionField.value = resultText;
              }
              ocrOutput.textContent += `${field}: ${resultText}\n`;
            })
          );
        }
      }
      Promise.all(tasks).then(() => {
        ocrOutput.textContent += "全領域のOCR処理完了。";
      });
    });
    
    /*************************************
     * ocrWholeButton
     * 全体OCR処理を実行し、その結果からグループ化を行い赤枠情報を保存する
     * スクリーン２遷移時に自動で実行される
     *************************************/
    ocrWholeButton.addEventListener('click', async function() {
      ocrOutput.textContent = "全体OCR実行中...\n";
      if (!fsImage.src) {
        console.error("fsImage.src が設定されていません。");
        ocrOutput.textContent += "エラー: 画像が読み込まれていません。\n";
        return;
      }
      const worker = Tesseract.createWorker({ logger: m => console.log("全体OCR:", m) });
      try {
        await worker.load();
        await worker.loadLanguage('jpn');
        await worker.initialize('jpn');
        const { data } = await worker.recognize(fsImage.src);
        lastOcrData = data;
        ocrOutput.textContent += "全体OCR完了。\n";
        // グループ化のみを実施（マージ処理は行わず、赤枠情報を保持）
        displayGroupedText(data);
      } catch (err) {
        console.error("全体OCRエラー:", err);
        ocrOutput.textContent += "エラーが発生しました。\n" + err;
      } finally {
        await worker.terminate();
      }
    });
    
    /*************************************
     * 傾き補正＋グループ分け＋横分割用関数群
     *************************************/
    // completeBBox: 各単語のバウンディングボックスの端点が存在しない場合に補完する
    function completeBBox(bbox) {
      if (bbox.tl && bbox.tr && bbox.br && bbox.bl) return bbox;
      return { tl: { x: bbox.x0, y: bbox.y0 }, tr: { x: bbox.x1, y: bbox.y0 }, br: { x: bbox.x1, y: bbox.y1 }, bl: { x: bbox.x0, y: bbox.y1 } };
    }
    
    // computeAverageTilt: 単語ごとに左側の線の傾きを計算し、平均傾きを返す
    function computeAverageTilt(words) {
      let sum = 0, count = 0;
      words.forEach(word => {
        let bbox = completeBBox(word.bbox);
        let tl = bbox.tl, bl = bbox.bl;
        let dx = bl.x - tl.x, dy = bl.y - tl.y;
        if (Math.abs(dx) > 0.001) { sum += Math.atan2(dy, dx); count++; }
      });
      return count > 0 ? sum / count : 0;
    }
    
    // rotatePoint: 指定した角度で点の回転を行う
    function rotatePoint(point, angle) {
      let cos = Math.cos(angle), sin = Math.sin(angle);
      return { x: point.x * cos - point.y * sin, y: point.x * sin + point.y * cos };
    }
    
    // augmentWordsWithRotatedLeftY: 各単語の左側の中心座標と幅を、画像の傾きを補正した上で計算する
    function augmentWordsWithRotatedLeftY(words, avgAngle) {
      return words.map(word => {
        let bbox = completeBBox(word.bbox);
        let rtl = rotatePoint(bbox.tl, -avgAngle);
        let rbl = rotatePoint(bbox.bl, -avgAngle);
        let leftYMid = (rtl.y + rbl.y) / 2;
        let thresh = Math.abs(rtl.y - leftYMid);
        let leftXMid = (rtl.x + rbl.x) / 2;
        let rtr = rotatePoint(bbox.tr, -avgAngle);
        let rotatedWidth = Math.abs(rtr.x - rtl.x);
        return Object.assign({}, word, { rotatedLeftYMid: leftYMid, thresh: thresh, rotatedLeftX: leftXMid, rotatedWidth: rotatedWidth });
      });
    }
    
    // groupWordsByLineTilt: 単語を縦方向の中心座標でグループ化する
    function groupWordsByLineTilt(words) {
      let sorted = words.slice().sort((a, b) => a.rotatedLeftYMid - b.rotatedLeftYMid);
      let groups = [], currentGroup = [];
      sorted.forEach(word => {
        if (currentGroup.length === 0) currentGroup.push(word);
        else {
          let prev = currentGroup[currentGroup.length - 1];
          let tol = Math.min(prev.thresh, word.thresh);
          if (Math.abs(word.rotatedLeftYMid - prev.rotatedLeftYMid) < tol) currentGroup.push(word);
          else { groups.push(currentGroup); currentGroup = [word]; }
        }
      });
      if (currentGroup.length > 0) groups.push(currentGroup);
      return groups;
    }
    
    // groupWordsHorizontally: 各行内の単語を横方向の位置でグループ化する
    function groupWordsHorizontally(words) {
      let sorted = words.slice().sort((a, b) => a.rotatedLeftX - b.rotatedLeftX);
      let totalWidth = sorted.reduce((sum, w) => sum + w.rotatedWidth, 0);
      let avgWidth = sorted.length > 0 ? totalWidth / sorted.length : 0;
      let horizThreshold = 1.5 * avgWidth;
      let groups = [], currentGroup = [];
      sorted.forEach(word => {
        if (currentGroup.length === 0) currentGroup.push(word);
        else {
          let prev = currentGroup[currentGroup.length - 1];
          let prevRight = prev.rotatedLeftX + prev.rotatedWidth;
          let gap = word.rotatedLeftX - prevRight;
          if (gap > horizThreshold) { groups.push(currentGroup); currentGroup = [word]; }
          else currentGroup.push(word);
        }
      });
      if (currentGroup.length > 0) groups.push(currentGroup);
      return groups;
    }
    
    // displayGroupedText: 全体OCR結果から単語をグループ化し、各グループの赤枠座標情報を算出・保存する
    function displayGroupedText(data) {
      drawFsCanvas();
      let avgAngle = computeAverageTilt(data.words);
      let wordsRotated = augmentWordsWithRotatedLeftY(data.words, avgAngle);
      let verticalGroups = groupWordsByLineTilt(wordsRotated);
      let finalGroups = [];
      verticalGroups.forEach(group => {
        let horizontalGroups = groupWordsHorizontally(group);
        horizontalGroups.forEach(subgroup => finalGroups.push(subgroup));
      });
      let groupedText = "\n【グループ化されたOCR結果】\n";
      // 算出された各グループのバウンディングボックスを計算する
      let boxes = finalGroups.map((group, index) => {
        groupedText += `Group ${index + 1}: ${group.map(w => w.text).join(" ")}\n`;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        group.forEach(word => {
          let bbox = completeBBox(word.bbox);
          let rtl = rotatePoint(bbox.tl, -avgAngle);
          let rtr = rotatePoint(bbox.tr, -avgAngle);
          let rbr = rotatePoint(bbox.br, -avgAngle);
          let rbl = rotatePoint(bbox.bl, -avgAngle);
          minX = Math.min(minX, rtl.x, rtr.x, rbr.x, rbl.x);
          minY = Math.min(minY, rtl.y, rtr.y, rbr.y, rbl.y);
          maxX = Math.max(maxX, rtl.x, rtr.x, rbr.x, rbl.x);
          maxY = Math.max(maxY, rtl.y, rtr.y, rbr.y, rbl.y);
        });
        return { x: minX * fsScale, y: minY * fsScale, width: (maxX - minX) * fsScale, height: (maxY - minY) * fsScale };
      });
      ocrOutput.textContent += groupedText;
      console.log(groupedText);
      // 保存：算出した赤枠情報をlastGroupBoxesに保存する（フィールドリセットまで保持）
      lastGroupBoxes = boxes;
      drawGroupedBoxes(boxes);
    }
    
    // updateGroupedBoxes: 再OCR結果などをもとに、赤枠情報を更新して描画する
    function updateGroupedBoxes() {
      if (!lastOcrData) return;
      drawFsCanvas();
      let avgAngle = computeAverageTilt(lastOcrData.words);
      let wordsRotated = augmentWordsWithRotatedLeftY(lastOcrData.words, avgAngle);
      let verticalGroups = groupWordsByLineTilt(wordsRotated);
      let finalGroups = [];
      verticalGroups.forEach(group => {
        let horizontalGroups = groupWordsHorizontally(group);
        horizontalGroups.forEach(subgroup => finalGroups.push(subgroup));
      });
      let boxes = finalGroups.map(group => {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        group.forEach(word => {
          let bbox = completeBBox(word.bbox);
          let rtl = rotatePoint(bbox.tl, -avgAngle);
          let rtr = rotatePoint(bbox.tr, -avgAngle);
          let rbr = rotatePoint(bbox.br, -avgAngle);
          let rbl = rotatePoint(bbox.bl, -avgAngle);
          minX = Math.min(minX, rtl.x, rtr.x, rbr.x, rbl.x);
          minY = Math.min(minY, rtl.y, rtr.y, rbr.y, rbl.y);
          maxX = Math.max(maxX, rtl.x, rtr.x, rbr.x, rbl.x);
          maxY = Math.max(maxY, rtl.y, rtr.y, rbr.y, rbl.y);
        });
        return { x: minX * fsScale, y: minY * fsScale, width: (maxX - minX) * fsScale, height: (maxY - minY) * fsScale };
      });
      lastGroupBoxes = boxes;
      drawGroupedBoxes(boxes);
    }
    
    // drawGroupedBoxes: 赤枠として各グループのバウンディングボックスを描画する
    function drawGroupedBoxes(boxes) {
      boxes.forEach((box, index) => {
        fsCtx.strokeStyle = "red"; // 赤枠で描画
        fsCtx.lineWidth = 3;
        fsCtx.strokeRect(box.x, box.y, box.width, box.height);
        fsCtx.fillStyle = "red";
        fsCtx.font = "16px Arial";
        fsCtx.textBaseline = "top";
        fsCtx.textAlign = "left";
        fsCtx.fillText("Group " + (index + 1), box.x, box.y - 5);
      });
    }
    
    /*************************************
     * performOCROnField: 指定領域に対してOCR処理を実施する
     *************************************/
    function performOCROnField(field, region) {
      return new Promise((resolve, reject) => {
        const originalX = region.x / fsScale;
        const originalY = region.y / fsScale;
        const originalWidth = region.width / fsScale;
        const originalHeight = region.height / fsScale;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = originalWidth;
        tempCanvas.height = originalHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(fsImage, originalX, originalY, originalWidth, originalHeight, 0, 0, originalWidth, originalHeight);
        const croppedDataURL = tempCanvas.toDataURL();
        binarizeImage(croppedDataURL).then(binarizedDataURL => {
          Tesseract.recognize(
            binarizedDataURL,
            'jpn',
            {
              langPath: 'https://tessdata.projectnaptha.com/4.0.0_best/',
              logger: m => console.log(field, m),
              tessedit_char_whitelist: '0123456789年月日-/： ',
              tessedit_pageseg_mode: 6
            }
          ).then(({ data: { text } }) => {
            resolve(replaceCircledNumbers(text).trim());
          }).catch(err => {
            console.error(field, err);
            resolve("エラー");
          });
        }).catch(err => {
          console.error("Binarization error", err);
          resolve("エラー");
        });
      });
    }
    
    /*************************************
     * binarizeImage: 画像を二値化し、OCRに適した状態に変換する
     *************************************/
    function binarizeImage(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          const src = cv.imread(canvas);
          const gray = new cv.Mat();
          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
          const binary = new cv.Mat();
          cv.threshold(gray, binary, 128, 255, cv.THRESH_BINARY);
          cv.imshow(canvas, binary);
          const resultDataURL = canvas.toDataURL();
          src.delete(); gray.delete(); binary.delete();
          resolve(resultDataURL);
        };
        img.onerror = function(err) { reject(err); };
        img.src = dataURL;
      });
    }
    
    /*************************************
     * replaceCircledNumbers: 囲み数字を通常の数字に置換する
     *************************************/
    function replaceCircledNumbers(text) {
      const mapping = {
        '⓪': '0', '①': '1', '②': '2', '③': '3', '④': '4',
        '⑤': '5', '⑥': '6', '⑦': '7', '⑧': '8', '⑨': '9',
        '⑩': '10', '⑪': '11', '⑫': '12'
      };
      return text.replace(/[⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫]/g, match => mapping[match] || match);
    }
    
    /*************************************
     * processDateField: 日付フィールド用に和暦を西暦に変換する
     *************************************/
    function processDateField(text) {
      if (text.includes("令和") || text.includes("平成") || text.includes("昭和")) {
        return convertJapaneseEra(text);
      }
      return text;
    }
    
    /*************************************
     * processAmountField: 金額フィールドから数字以外を削除する
     *************************************/
    function processAmountField(text) {
      return text.replace(/\D/g, "");
    }
    
    /*************************************
     * convertJapaneseEra: 和暦を西暦に変換する
     *************************************/
    function convertJapaneseEra(dateStr) {
      const match = dateStr.match(/(令和|平成|昭和)(元|\d+)[年](\d{1,2})[月](\d{1,2})[日]/);
      if (match) {
        const era = match[1];
        const yearPart = match[2];
        const month = match[3];
        const day = match[4];
        let offset = 0;
        if (era === "令和") offset = 2018;
        else if (era === "平成") offset = 1988;
        else if (era === "昭和") offset = 1925;
        const year = (yearPart === "元") ? offset + 1 : parseInt(yearPart, 10) + offset;
        return year + "年" + month + "月" + day + "日";
      }
      return dateStr;
    }
    
    /*************************************
     * 回転・反転処理
     *************************************/
    const rotate90Button = document.getElementById('rotate90Button');
    const rotateNeg90Button = document.getElementById('rotateNeg90Button');
    const flipButton = document.getElementById('flipButton');
    
    rotate90Button.addEventListener('click', function() {
      rotateImage(correctedImage.src, 90).then(newDataURL => {
        correctedImage.src = newDataURL;
        fsImage.src = newDataURL;
      });
    });
    
    rotateNeg90Button.addEventListener('click', function() {
      rotateImage(correctedImage.src, -90).then(newDataURL => {
        correctedImage.src = newDataURL;
        fsImage.src = newDataURL;
      });
    });
    
    flipButton.addEventListener('click', function() {
      flipImage(correctedImage.src).then(newDataURL => {
        correctedImage.src = newDataURL;
        fsImage.src = newDataURL;
      });
    });
    
    function rotateImage(dataURL, angle) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          // キャンバスサイズは回転角度によって入れ替える
          if (angle % 180 !== 0) {
            canvas.width = img.height;
            canvas.height = img.width;
          } else {
            canvas.width = img.width;
            canvas.height = img.height;
          }
          ctx.save();
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.rotate(angle * Math.PI / 180);
          ctx.drawImage(img, -img.width / 2, -img.height / 2);
          ctx.restore();
          resolve(canvas.toDataURL());
        };
        img.onerror = reject;
        img.src = dataURL;
      });
    }
    
    function flipImage(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.save();
          ctx.translate(img.width, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(img, 0, 0);
          ctx.restore();
          resolve(canvas.toDataURL());
        };
        img.onerror = reject;
        img.src = dataURL;
      });
    }
    
    /*************************************
     * スライダー処理
     *************************************/
    const groupThresholdSlider = document.getElementById("groupThresholdSlider");
    const groupThresholdValue = document.getElementById("groupThresholdValue");
    groupThresholdSlider.addEventListener("input", () => {
      groupThresholdValue.textContent = groupThresholdSlider.value;
      updateGroupedBoxes();
    });
    
    const overlapThresholdSlider = document.getElementById("overlapThresholdSlider");
    const overlapThresholdValue = document.getElementById("overlapThresholdValue");
    overlapThresholdSlider.addEventListener("input", () => {
      overlapThresholdValue.textContent = overlapThresholdSlider.value;
      updateGroupedBoxes();
    });
    
    /*************************************
     * キャンバス上でグループ枠をクリックして選択する処理
     * クリックした位置に合致するグループがあれば、そのインデックスをselectedGroupIndexにセット
     * その後、入力フォームがフォーカスされていれば自動でOCR結果を貼り付ける
     *************************************/
    fsCanvas.addEventListener("click", function(e) {
      // キャンバス上のクリック座標を計算
      const rect = fsCanvas.getBoundingClientRect();
      const scaleX = fsCanvas.width / rect.width;
      const scaleY = fsCanvas.height / rect.height;
      const clickX = (e.clientX - rect.left) * scaleX;
      const clickY = (e.clientY - rect.top) * scaleY;
      console.log("Canvas click:", clickX, clickY);
      let foundIndex = null;
      for(let i = 0; i < lastGroupBoxes.length; i++){
        let box = lastGroupBoxes[i];
        if(clickX >= box.x && clickX <= box.x + box.width &&
           clickY >= box.y && clickY <= box.y + box.height){
          foundIndex = i;
          break;
        }
      }
      if(foundIndex !== null){
        console.log("Selected group index:", foundIndex);
        selectedGroupIndex = foundIndex;
        drawFsCanvas(); // 赤枠は常に描画、選択枠はオレンジでハイライト
        // もしすでに入力フォームがフォーカスされていれば自動で貼り付け
        if(currentInput){
          pasteOcrResultIntoInput();
        }
      } else {
        console.log("クリック位置に一致するグループ枠がありません。");
        drawFsCanvas();
      }
    });
    
  </script>
</body>
</html>
